#include "ecc.h"

namespace lmcu::hash {


void ecc256_calculate(const uint8_t data[], uint8_t ecc[])
{
  static constexpr uint8_t ecc256_table[] = {
    0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
    0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
    0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
    0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
    0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
    0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
    0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
    0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
    0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
    0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
    0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
    0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
    0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
    0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
    0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
    0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
  };

  uint8_t idx, reg1 = 0, reg2 = 0, reg3 = 0, tmp1, tmp2;

  // build up column parity
  for(uint32_t i = 0; i < 256; i++) {
    // get CP0 - CP5 from table
    idx = ecc256_table[*data++];
    reg1 ^= (idx & 0x3f);

    // all bit XOR = 1 ?
    if (idx & 0x40) {
      reg3 ^=  uint8_t(i);
      reg2 ^= ~uint8_t(i);
    }
  }

  // create non-inverted ECC code from line parity
  tmp1  = (reg3 & 0x80) >> 0; // B7 -> B7
  tmp1 |= (reg2 & 0x80) >> 1; // B7 -> B6
  tmp1 |= (reg3 & 0x40) >> 1; // B6 -> B5
  tmp1 |= (reg2 & 0x40) >> 2; // B6 -> B4
  tmp1 |= (reg3 & 0x20) >> 2; // B5 -> B3
  tmp1 |= (reg2 & 0x20) >> 3; // B5 -> B2
  tmp1 |= (reg3 & 0x10) >> 3; // B4 -> B1
  tmp1 |= (reg2 & 0x10) >> 4; // B4 -> B0

  tmp2  = (reg3 & 0x08) << 4; // B3 -> B7
  tmp2 |= (reg2 & 0x08) << 3; // B3 -> B6
  tmp2 |= (reg3 & 0x04) << 3; // B2 -> B5
  tmp2 |= (reg2 & 0x04) << 2; // B2 -> B4
  tmp2 |= (reg3 & 0x02) << 2; // B1 -> B3
  tmp2 |= (reg2 & 0x02) << 1; // B1 -> B2
  tmp2 |= (reg3 & 0x01) << 1; // B0 -> B1
  tmp2 |= (reg2 & 0x01) << 0; // B7 -> B0

  // calculate final ECC code
  ecc[0] = ~tmp2;
  ecc[1] = ~tmp1;
  ecc[2] = ((~reg1) << 2) | 0x03;
}

ecc_result ecc256_correct(uint8_t data[], const uint8_t read_ecc[3], const uint8_t calc_ecc[3])
{
  uint8_t s0, s1, s2;

  s0 = calc_ecc[0] ^ read_ecc[0];
  s1 = calc_ecc[1] ^ read_ecc[1];
  s2 = calc_ecc[2] ^ read_ecc[2];

  if((s0 | s1 | s2) == 0) { return ecc_result::success; }

  // Ñheck for a single bit error
  if(
    ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54
  ) {
    uint32_t byteoffs, bitnum;

    byteoffs  = (s1 << 0) & 0x80;
    byteoffs |= (s1 << 1) & 0x40;
    byteoffs |= (s1 << 2) & 0x20;
    byteoffs |= (s1 << 3) & 0x10;

    byteoffs |= (s0 >> 4) & 0x08;
    byteoffs |= (s0 >> 3) & 0x04;
    byteoffs |= (s0 >> 2) & 0x02;
    byteoffs |= (s0 >> 1) & 0x01;

    bitnum    = (s2 >> 5) & 0x04;
    bitnum   |= (s2 >> 4) & 0x02;
    bitnum   |= (s2 >> 3) & 0x01;

    data[byteoffs] ^= (1 << bitnum);

    return ecc_result::corrected;
  }

  if(__builtin_popcount(s0 | (uint32_t(s1) << 8) | (uint32_t(s2) << 16)) == 1) {
    return ecc_result::corrected;
  }

  return ecc_result::error;
}

} // namespace lmcu::hash

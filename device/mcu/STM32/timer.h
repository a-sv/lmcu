#pragma once
#include <lmcu/device>
#include <lmcu/hwi/common>

namespace lmcu::timer {

enum class module_id
{
#if defined(TIM1)
  tim1,
#endif

#if defined(TIM2)
  tim2,
#endif

#if defined(TIM3)
  tim3,
#endif

#if defined(TIM4)
  tim4,
#endif

#if defined(TIM5)
  tim5,
#endif

#if defined(TIM6)
  tim6,
#endif

#if defined(TIM7)
  tim7,
#endif

#if defined(TIM8)
  tim8,
#endif

#if defined(TIM9)
  tim9,
#endif

#if defined(TIM10)
  tim10,
#endif

#if defined(TIM11)
  tim11,
#endif

#if defined(TIM12)
  tim12,
#endif

#if defined(TIM13)
  tim13,
#endif

#if defined(TIM14)
  tim14
#endif
};

enum class counter_mode
{
  // Up counting.
  up,

  // Down counting.
  down,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is
  // counting down.
  center_aligned_1,

  // Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt
  // flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the
  // counter is counting up.
  center_aligned_2,

  // Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt
  // flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the
  // counter is counting up or down.
  center_aligned_3
};

// Division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock
// (tDTS) used by the dead-time generators and the digital filters.
enum class clock_prediv { _1, _2, _4 };

// ARR register buffer enable / disable.
enum class arr_buffer { enable, disable };

// If enabled, counter stops counting at the next update event (clearing the bit CEN)
enum class one_pulse { enable, disable };

enum class update_request_source
{
  // Any of the following events generate an update interrupt or DMA request if enabled.
  // These events can be:
  //   - Counter overflow/underflow
  //   - Setting the UG bit
  //   - Update generation through the slave mode controller
  any,

  // Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
  ovf_udf
};

enum class ti1_selection
{
  // The TIMx_CH1 pin is connected to TI1 input
  ch_1,

  // The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
  ch_1_2_3
};

enum class master_mode
{
  // The UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is
  // generated by the trigger input (slave mode controller configured in reset mode) then the
  // signal on TRGO is delayed compared to the actual reset.
  reset,

  // The Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start
  // several timers at the same time or to control a window in which a slave timer is enable. The
  // Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input
  // when configured in gated mode. When the Counter Enable signal is controlled by the trigger
  // input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit
  // description in TIMx_SMCR register).
  enable,

  // The update event is selected as trigger output (TRGO). For instance a master timer can then be
  // used as a prescaler for a slave timer.
  update,

  // The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was
  // already high), as soon as a capture or a compare match occurred.
  comp_pulse,

  // OC1REF signal is used as trigger output (TRGO).
  comp_1,

  // OC2REF signal is used as trigger output (TRGO).
  comp_2,

  // OC3REF signal is used as trigger output (TRGO).
  comp_3,

  // OC4REF signal is used as trigger output (TRGO).
  comp_4
};

// Capture/compare DMA selection.
enum class dma_triger
{
  // DMA request sent when CCx event occurs.
  capture_compare,

  // DMA requests sent when update event occurs.
  update
};

// Capture/compare control update selection.
enum class cc_ctrl_update
{
  // When capture/compare control bits are preloaded (CCPC=1), they are updated by setting:

  disable,

  //   - COMG bit only
  comg,

  //   - COMG and TRGI
  comg_trgi
};

enum class slave_mode { disable, enable };

// External trigger polarity
enum class ex_trig_polarity { low, high };

// External trigger prescaler
enum class ex_trig_div { _1, _2, _4, _8 };

// External trigger filter
enum class ex_trig_filter
{
  // Defines the frequency used to sample ETRP signal and the length of the digital filter applied
  // to ETRP. The digital filter is made of an event counter in which N consecutive events are
  // needed to validate a transition on the output.
  disable,
  ckint_n2, // fSAMPLING=fCK_INT, N=2
  ckint_n4, // fSAMPLING=fCK_INT, N=4
  ckint_n8, // fSAMPLING=fCK_INT, N=8
  dts2_n6,  // fSAMPLING=fDTS/2,  N=6
  dts2_n8,  // fSAMPLING=fDTS/2,  N=8
  dts4_n6,  // fSAMPLING=fDTS/4,  N=6
  dts4_n8,  // fSAMPLING=fDTS/4,  N=8
  dts8_n6,  // fSAMPLING=fDTS/8,  N=6
  dts8_n8,  // fSAMPLING=fDTS/8,  N=8
  dts16_n5, // fSAMPLING=fDTS/16, N=5
  dts16_n6, // fSAMPLING=fDTS/16, N=6
  dts16_n8, // fSAMPLING=fDTS/16, N=8
  dts32_n5, // fSAMPLING=fDTS/32, N=5
  dts32_n6, // fSAMPLING=fDTS/32, N=6
  dts32_n8  // fSAMPLING=fDTS/32, N=8
};

enum class trig_selection
{
  itr0,
  itr1,
  itr2,
  itr3,
  ti1f_ed,
  ti1f_p1,
  ti2f_p2,
  etrf
};

// External clock enable
enum class ex_clock { disable, enable };

enum class tim_type { basic, general, advanced };

template<
  module_id _module_id,
  counter_mode _counter_mode = counter_mode::up,
  clock_prediv _clock_prediv = clock_prediv::_1,
  uint32_t _rep_count = 0,
  arr_buffer _arr_buffer = arr_buffer::disable,
  one_pulse _one_pulse = one_pulse::disable,
  update_request_source _update_request_source = update_request_source::any,
  ti1_selection _ti1_selection = ti1_selection::ch_1,
  master_mode _master_mode = master_mode::reset,
  dma_triger _dma_triger = dma_triger::capture_compare,
  cc_ctrl_update _cc_ctrl_update = cc_ctrl_update::disable,
  slave_mode _slave_mode = slave_mode::disable,
  ex_trig_polarity _ex_trig_polarity = ex_trig_polarity::high,
  ex_clock _ex_clock = ex_clock::disable,
  ex_trig_div _ex_trig_div = ex_trig_div::_1,
  ex_trig_filter _ex_trig_filter = ex_trig_filter::disable,
  trig_selection _trig_selection = trig_selection::itr0
>
struct module
{
  static constexpr auto dev_class = lmcu::dev_class::timer;
  static constexpr auto module_id = _module_id;
  static constexpr auto counter_mode = _counter_mode;
  static constexpr auto clock_prediv = _clock_prediv;
  static constexpr auto rep_count = _rep_count;
  static constexpr auto arr_buffer = _arr_buffer;
  static constexpr auto one_pulse = _one_pulse;
  static constexpr auto update_request_source = _update_request_source;
  static constexpr auto ti1_selection = _ti1_selection;
  static constexpr auto master_mode = _master_mode;
  static constexpr auto dma_triger = _dma_triger;
  static constexpr auto cc_ctrl_update = _cc_ctrl_update;
  static constexpr auto slave_mode = _slave_mode;
  static constexpr auto ex_trig_polarity = _ex_trig_polarity;
  static constexpr auto ex_clock = _ex_clock;
  static constexpr auto ex_trig_div = _ex_trig_div;
  static constexpr auto ex_trig_filter = _ex_trig_filter;
  static constexpr auto trig_selection = _trig_selection;
};

enum class oc_channel { oc_1, oc_2, oc_3, oc_4 };

enum class oc_mode
{
  timing,
  active,
  inactive,
  toggle,
  pwm1,
  pwm2,
  pwm1_fast,
  pwm2_fast,
  forced_active,
  forced_inactive
};

enum class oc_polarity { low, high };
using oc_n_polarity = oc_polarity;

// Specifies the TIM Output Compare pin state during Idle state.
enum class oc_idle_state { low, high };
using oc_n_idle_state = oc_idle_state;

template<
  typename _module,
  oc_channel _oc_channel,
  oc_mode _oc_mode,
  oc_polarity _oc_polarity = oc_polarity::low,
  oc_idle_state _oc_idle_state = oc_idle_state::low,
  oc_n_polarity _oc_n_polarity = oc_n_polarity::low,
  oc_n_idle_state _oc_n_idle_state = oc_n_idle_state::low
>
struct oc_conf
{
  static constexpr auto dev_class = lmcu::dev_class::timer_oc;
  static constexpr auto module = _module();
  static constexpr auto oc_channel = _oc_channel;
  static constexpr auto oc_mode = _oc_mode;
  static constexpr auto oc_polarity = _oc_polarity;
  static constexpr auto oc_idle_state = _oc_idle_state;
  static constexpr auto oc_n_polarity = _oc_n_polarity;
  static constexpr auto oc_n_idle_state = _oc_n_idle_state;
};

enum class oc_type : uint32_t
{
  lmcu_flags_object,

  main = 1 << 0,
  comp = 1 << 1
};

#include "detail/timer.h"

template<typename ..._modules>
void configure() { detail::configure<_modules...>(); }

template<typename _module>
void set_prescaler(uint16_t val) { detail::set_prescaler<_module>(val); }

template<typename _module>
void set_period(uint16_t val) { detail::set_period<_module>(val); }

template<typename _oc_conf>
void set_pulse(uint16_t val) { detail::set_pulse<_oc_conf>(val); }

template<typename _module>
void emit_update_event() { detail::emit_update_event<_module>(); }

template<typename ..._modules>
void enable() { detail::enable<_modules...>(); }

template<typename ..._modules>
void disable() { detail::disable<_modules...>(); }

template<typename _module>
constexpr tim_type get_tim_type() { return detail::get_tim_type<_module>(); }

template<typename ..._modules>
void main_output_enable() { detail::main_output_enable<_modules...>(); }

template<typename ..._modules>
void main_output_disable() { detail::main_output_disable<_modules...>(); }

template<typename _module_oc, oc_type _oc_type>
void channel_enable() { detail::channel_enable<_module_oc, _oc_type>(); }

template<typename _module_oc, oc_type _oc_type>
void channel_disable() { detail::channel_disable<_module_oc, _oc_type>(); }

template<typename ..._modules>
void set_deadtime(uint8_t val) { detail::set_deadtime<_modules...>(val); }


} // namespace lmcu::timer

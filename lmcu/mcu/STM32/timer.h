#pragma once
#include <lmcu/dev/timer>
#include <lmcu/dev/rcc>
#include <lmcu/irq>
#include <lmcu/common>

namespace lmcu::timer {

enum class id {
  tim1,
  tim2,
  tim3,
  tim4,
  tim5,
  tim6,
  tim7,
  tim8,
  tim9,
  tim10,
  tim11,
  tim12,
  tim13,
  tim14
};

enum class update_request_src
{
  // Any of the following events generate an update interrupt or DMA request if enabled.
  // These events can be:
  //   - Counter overflow/underflow
  //   - Setting the UG bit
  //   - Update generation through the slave mode controller
  any,

  // Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
  ovf_udf
};

enum class update { disable, enable };

enum class one_pulse { disable, enable };

enum class direction { up, down };

enum class center_align
{
  // Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
  disable,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is
  // counting down.
  down,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is
  // counting up.
  up,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is
  // counting up or down.
  up_down
};

enum class auto_reload { disable, enable };

enum class dtg_df_div
{
  _1, // tDTS = tCK_INT
  _2, // tDTS = 2 * tCK_INT
  _4  // tDTS = 4*tCK_INT
};

enum class cc_update
{
  disable,
  // COMG bit only
  comg,
  // COMG and TRGI
  comg_trgi
};

enum class dma_trig
{
  // DMA request sent when CCx event occurs.
  cc_evt,
  // DMA requests sent when update event occurs.
  update_evt
};

enum class master_mode
{
  // The UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is
  // generated by the trigger input (slave mode controller configured in reset mode) then the
  // signal on TRGO is delayed compared to the actual reset.
  reset,

  // The Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start
  // several timers at the same time or to control a window in which a slave timer is enable. The
  // Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input
  // when configured in gated mode. When the Counter Enable signal is controlled by the trigger
  // input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit
  // description in TIMx_SMCR register).
  enable,

  // The update event is selected as trigger output (TRGO). For instance a master timer can then be
  // used as a prescaler for a slave timer.
  update,

  // The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was
  // already high), as soon as a capture or a compare match occurred.
  comp_pulse,

  // OC1REF signal is used as trigger output (TRGO).
  comp_1,

  // OC2REF signal is used as trigger output (TRGO).
  comp_2,

  // OC3REF signal is used as trigger output (TRGO).
  comp_3,

  // OC4REF signal is used as trigger output (TRGO).
  comp_4
};

enum class ti1_mux
{
  // The TIMx_CH1 pin is connected to TI1 input
  ch1,

  // The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
  ch1_ch2_ch3
};

enum class slave_mode
{
  // Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal
  // clock.
  disable,

  // Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
  encoder_1,

  // Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
  encoder_2,

  // Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other
  // input.
  encoder_3,

  // Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an
  // update of the registers.
  reset,

  // The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is
  // not reset) as soon as the trigger becomes low. Both start and stop of the counter are
  // controlled.
  gated,

  // The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start
  // of the counter is controlled.
  trigger,

  // External Clock - Rising edges of the selected trigger (TRGI) clock the counter.
  ext_clock
};

enum class slave_trig_sel
{
  itr0, // Internal Trigger 0 (ITR0)
  itr1, // Internal Trigger 1 (ITR1)
  itr2, // Internal Trigger 2 (ITR2)
  itr3, // Internal Trigger 3 (ITR3)
  ti1f_ed, // TI1 Edge Detector (TI1F_ED)
  ti1f_p1, // Filtered Timer Input 1 (TI1FP1)
  ti2f_p2, // Filtered Timer Input 2 (TI2FP2)
  etrf // External Trigger input (ETRF)
};

enum class master_slave_mode { disable, enable };

enum class ext_trig_filter
{
  // Defines the frequency used to sample ETRP signal and the length of the digital filter applied
  // to ETRP. The digital filter is made of an event counter in which N consecutive events are
  // needed to validate a transition on the output.
  disable,
  ckint_n2, // fSAMPLING = fCK_INT,   N=2
  ckint_n4, // fSAMPLING = fCK_INT,   N=4
  ckint_n8, // fSAMPLING = fCK_INT,   N=8
  dts2_n6,  // fSAMPLING = fDTS / 2,  N=6
  dts2_n8,  // fSAMPLING = fDTS / 2,  N=8
  dts4_n6,  // fSAMPLING = fDTS / 4,  N=6
  dts4_n8,  // fSAMPLING = fDTS / 4,  N=8
  dts8_n6,  // fSAMPLING = fDTS / 8,  N=6
  dts8_n8,  // fSAMPLING = fDTS / 8,  N=8
  dts16_n5, // fSAMPLING = fDTS / 16, N=5
  dts16_n6, // fSAMPLING = fDTS / 16, N=6
  dts16_n8, // fSAMPLING = fDTS / 16, N=8
  dts32_n5, // fSAMPLING = fDTS / 32, N=5
  dts32_n6, // fSAMPLING = fDTS / 32, N=6
  dts32_n8  // fSAMPLING = fDTS / 32, N=8
};

enum class ext_trig_div { _1, _2, _4, _8 };

enum class ext_clock { disable, enable };

enum class ext_trig_polarity { low, high };

enum class main_output { disable, enable };

enum class main_auto_output { disable, enable };

enum class break_polarity { low, high };

enum class break_input { disable, enable };

enum class off_state_run { low, high };

enum class off_state_idle { low, high };

enum class lock { off, level_1, level_2, level_3 };

enum class dma_burst_length
{
  _1,
  _2,
  _3,
  _4,
  _5,
  _6,
  _7,
  _8,
  _9,
  _10,
  _11,
  _12,
  _13,
  _14,
  _15,
  _16,
  _17,
  _18
};

enum class dma_base_address_adv
{
  cr1,
  cr2,
  smcr,
  dier,
  sr,
  egr,
  ccmr1,
  ccmr2,
  ccer,
  cnt,
  psc,
  arr,
  rcr,
  ccr1,
  ccr2,
  ccr3,
  ccr4,
  bdtr,
  dcr,
  dmar
};

enum class dma_base_address_gp
{
  cr1,
  cr2,
  smcr,
  dier,
  sr,
  egr,
  ccmr1,
  ccmr2,
  ccer,
  cnt,
  psc,
  arr,
  ccr1,
  ccr2,
  ccr3,
  ccr4,
  dcr,
  dmar
};

enum class events : uint32_t
{
  lmcu_flags,

  ui   = device::TIM1::DIER::UIE,   // Update interrupt
  cc1i = device::TIM1::DIER::CC1IE, // Capture/Compare 1 interrupt
  cc2i = device::TIM1::DIER::CC2IE, // Capture/Compare 2 interrupt
  cc3i = device::TIM1::DIER::CC3IE, // Capture/Compare 3 interrupt
  cc4i = device::TIM1::DIER::CC4IE, // Capture/Compare 4 interrupt
  comi = device::TIM1::DIER::COMIE, // COM interrupt
  ti   = device::TIM1::DIER::TIE,   // Trigger interrupt
  bi   = device::TIM1::DIER::BIE,   // Break interrupt
  ud   = device::TIM1::DIER::UDE,   // Update DMA request
  cc1d = device::TIM1::DIER::CC1DE, // Capture/Compare 1 DMA request
  cc2d = device::TIM1::DIER::CC2DE, // Capture/Compare 2 DMA request
  cc3d = device::TIM1::DIER::CC3DE, // Capture/Compare 3 DMA request
  cc4d = device::TIM1::DIER::CC4DE, // Capture/Compare 4 DMA request
  comd = device::TIM1::DIER::COMDE, // COM DMA request
  tde  = device::TIM1::DIER::TDE    // Trigger DMA request
};

enum class counter { disable, enable };

enum class channel { _1, _2, _3, _4 };

enum class channel_en { disable, enable };

enum class channel_polarity { direct, inverted };

enum class channel_n_en { disable, enable };

enum class channel_n_polarity { direct, inverted };

enum class in_mode
{
  ti1, // TI1
  ti2, // TI2
  ti3, // TI3
  ti4, // TI4
  trc  // Internal trigger input
};

enum class in_div { _1, _2, _4, _8 };

enum class in_filter
{
  // Defines the frequency used to sample TI1 input and the length of the digital filter applied
  // to TI1. The digital filter is made of an event counter in which N consecutive events are needed
  // to validate a transition on the output.
  disable,
  ckint_n2, // fSAMPLING = fCK_INT,   N=2
  ckint_n4, // fSAMPLING = fCK_INT,   N=4
  ckint_n8, // fSAMPLING = fCK_INT,   N=8
  dts2_n6,  // fSAMPLING = fDTS / 2,  N=6
  dts2_n8,  // fSAMPLING = fDTS / 2,  N=8
  dts4_n6,  // fSAMPLING = fDTS / 4,  N=6
  dts4_n8,  // fSAMPLING = fDTS / 4,  N=8
  dts8_n6,  // fSAMPLING = fDTS / 8,  N=6
  dts8_n8,  // fSAMPLING = fDTS / 8,  N=8
  dts16_n5, // fSAMPLING = fDTS / 16, N=5
  dts16_n6, // fSAMPLING = fDTS / 16, N=6
  dts16_n8, // fSAMPLING = fDTS / 16, N=8
  dts32_n5, // fSAMPLING = fDTS / 32, N=5
  dts32_n6, // fSAMPLING = fDTS / 32, N=6
  dts32_n8  // fSAMPLING = fDTS / 32, N=8
};

enum class out_idle { low, high };

enum class out_n_idle { low, high };

enum class out_fast { disable, enable };

enum class out_preload { disable, enable };

enum class out_mode
{
  frozen,
  active_on_match,
  inactive_on_match,
  toggle,
  force_inactive,
  force_active,
  pwm_1,
  pwm_2
};

enum class out_clear { disable, enable };

struct irq : nvic::irq_config {};

struct brk_irq : nvic::irq_config {};

struct up_irq : nvic::irq_config {};

struct trg_com_irq : nvic::irq_config {};

struct cc_irq : nvic::irq_config {};

template<id _id, auto ..._args>
struct _dev;

template<id _id, auto ..._args>
struct _input;

template<id _id, auto ..._args>
struct _output;

/**
 * Timers 1, 8 config
*/
template<auto ..._args>
struct _dev<id::tim1, _args...>
{
  static constexpr auto dev_class = lmcu::dev_class::timer;

  static constexpr auto id = timer::id::tim1;

  // Update request source.
  static constexpr auto update_request_src = option::get<timer::update_request_src, _args...>(
                                               timer::update_request_src::any);
  // Enable/disable UEV event generation.
  static constexpr auto update = option::get<timer::update, _args...>(timer::update::enable);
  // One pulse mode.
  static constexpr auto one_pulse = option::get<timer::one_pulse, _args...>(timer::one_pulse::
                                                                            disable);
  // Count direction.
  static constexpr auto direction = option::get<timer::direction, _args...>(timer::direction::up);
  //  Center-aligned mode selection.
  static constexpr auto center_align = option::get<timer::center_align, _args...>(
                                         timer::center_align::disable);
  // Center-aligned mode selection.
  static constexpr auto auto_reload = option::get<timer::auto_reload, _args...>(timer::auto_reload::
                                                                                disable);
  // Dead time generator and digital filter clock division.
  static constexpr auto dtg_df_div = option::get<timer::dtg_df_div, _args...>(timer::dtg_df_div::
                                                                              _1);
  // Timer counter enable/disable.
  static constexpr auto counter = option::get<timer::counter, _args...>(timer::counter::disable);
  // Capture/compare control update selection.
  static constexpr auto cc_update = option::get<timer::cc_update, _args...>(timer::cc_update::
                                                                            disable);
  // Capture/compare DMA selection.
  static constexpr auto dma_trig = option::get<timer::dma_trig, _args...>(timer::dma_trig::
                                                                          cc_evt);
  // Master mode selection.
  static constexpr auto master_mode = option::get<timer::master_mode, _args...>(timer::master_mode::
                                                                                reset);
  // TI1 selection.
  static constexpr auto ti1_mux = option::get<timer::ti1_mux, _args...>(timer::ti1_mux::ch1);
  // Slave mode selection.
  static constexpr auto slave_mode = option::get<timer::slave_mode, _args...>(timer::slave_mode::
                                                                              disable);
  // Slave trigger selection.
  static constexpr auto slave_trig_sel = option::get<timer::slave_trig_sel, _args...>(
                                           timer::slave_trig_sel::itr0);
  // Master/slave mode.
  static constexpr auto master_slave_mode = option::get<timer::master_slave_mode, _args...>(
                                              timer::master_slave_mode::disable);
  // External trigger filter.
  static constexpr auto ext_trig_filter = option::get<timer::ext_trig_filter, _args...>(
                                            timer::ext_trig_filter::disable);
  // External trigger prescaler.
  static constexpr auto ext_trig_div = option::get<timer::ext_trig_div, _args...>(
                                         timer::ext_trig_div::_1);
  // External clock enable.
  static constexpr auto ext_clock = option::get<timer::ext_clock, _args...>(timer::ext_clock::
                                                                            disable);
  // External trigger polarity.
  static constexpr auto ext_trig_polarity = option::get<timer::ext_trig_polarity, _args...>(
                                              timer::ext_trig_polarity::high);
  // Enabled events.
  static constexpr auto events = option::get<timer::events, _args...>(timer::events(0));
  // Channels main output control.
  static constexpr auto main_output = option::get<timer::main_output, _args...>(timer::main_output::
                                                                                disable);
  // Automatic output control (activate main output if break input is not be active).
  static constexpr auto main_auto_output = option::get<timer::main_auto_output, _args...>(
                                             timer::main_auto_output::disable);
  // Break input polarity control.
  static constexpr auto break_polarity = option::get<timer::break_polarity, _args...>(
                                           timer::break_polarity::low);
  // Break input enable control.
  static constexpr auto break_input = option::get<timer::break_input, _args...>(timer::break_input::
                                                                                disable);
  // Off-state for Run mode.
  static constexpr auto off_state_run = option::get<timer::off_state_run, _args...>(
                                          timer::off_state_run::low);
  // Off-state for Idle mode.
  static constexpr auto off_state_idle = option::get<timer::off_state_idle, _args...>(
                                           timer::off_state_idle::low);
  // Lock config.
  static constexpr auto lock = option::get<timer::lock, _args...>(timer::lock::off);
  // DMA burst length.
  static constexpr auto dma_burst_length = option::get<timer::dma_burst_length, _args...>(
                                             timer::dma_burst_length::_1);
  // Initial register for DMA burst.
  static constexpr auto dma_base_address = option::get<timer::dma_base_address_adv, _args...>(
                                             timer::dma_base_address_adv::cr1);
  // Enable BRK irq.
  static constexpr auto brk_irq = option::get<timer::brk_irq, _args...>();
  // Enable UP irq.
  static constexpr auto up_irq = option::get<timer::up_irq, _args...>();
  // Enable TRG_COM irq.
  static constexpr auto trg_com_irq = option::get<timer::trg_com_irq, _args...>();
  // Enable CC irq.
  static constexpr auto cc_irq = option::get<timer::cc_irq, _args...>();

  static_assert(option::check<
    std::tuple<
      timer::id,
      timer::update_request_src,
      timer::update,
      timer::one_pulse,
      timer::direction,
      timer::center_align,
      timer::auto_reload,
      timer::dtg_df_div,
      timer::counter,
      timer::cc_update,
      timer::dma_trig,
      timer::master_mode,
      timer::ti1_mux,
      timer::slave_mode,
      timer::slave_trig_sel,
      timer::master_slave_mode,
      timer::ext_trig_filter,
      timer::ext_trig_div,
      timer::ext_clock,
      timer::ext_trig_polarity,
      timer::events,
      timer::main_output,
      timer::main_auto_output,
      timer::break_polarity,
      timer::break_input,
      timer::off_state_run,
      timer::off_state_idle,
      timer::lock,
      timer::dma_burst_length,
      timer::dma_base_address_adv,
      timer::brk_irq,
      timer::up_irq,
      timer::trg_com_irq,
      timer::cc_irq
    >,
    _args...
  >());
};

/**
 * Timers 2, 3, 4, 5 config
*/
template<auto ..._args>
struct _dev<id::tim2, _args...>
{
  static constexpr auto dev_class = lmcu::dev_class::timer;

  static constexpr auto id = timer::id::tim2;

  // Update request source.
  static constexpr auto update_request_src = option::get<timer::update_request_src, _args...>(
                                               timer::update_request_src::any);
  // Enable/disable UEV event generation.
  static constexpr auto update = option::get<timer::update, _args...>(timer::update::enable);
  // One pulse mode.
  static constexpr auto one_pulse = option::get<timer::one_pulse, _args...>(timer::one_pulse::
                                                                            disable);
  // Count direction.
  static constexpr auto direction = option::get<timer::direction, _args...>(timer::direction::up);
  //  Center-aligned mode selection.
  static constexpr auto center_align = option::get<timer::center_align, _args...>(
                                         timer::center_align::disable);
  // Center-aligned mode selection.
  static constexpr auto auto_reload = option::get<timer::auto_reload, _args...>(timer::auto_reload::
                                                                                disable);
  // Digital filter clock division.
  static constexpr auto dtg_df_div = option::get<timer::dtg_df_div, _args...>(timer::dtg_df_div::
                                                                              _1);
  // Timer counter enable/disable.
  static constexpr auto counter = option::get<timer::counter, _args...>(timer::counter::disable);
  // Capture/compare DMA selection.
  static constexpr auto dma_trig = option::get<timer::dma_trig, _args...>(timer::dma_trig::
                                                                          cc_evt);
  // Master mode selection.
  static constexpr auto master_mode = option::get<timer::master_mode, _args...>(timer::master_mode::
                                                                                reset);
  // TI1 selection.
  static constexpr auto ti1_mux = option::get<timer::ti1_mux, _args...>(timer::ti1_mux::ch1);
  // Slave mode selection.
  static constexpr auto slave_mode = option::get<timer::slave_mode, _args...>(timer::slave_mode::
                                                                              disable);
  // Slave trigger selection.
  static constexpr auto slave_trig_sel = option::get<timer::slave_trig_sel, _args...>(
                                           timer::slave_trig_sel::itr0);
  // Master/slave mode.
  static constexpr auto master_slave_mode = option::get<timer::master_slave_mode, _args...>(
                                              timer::master_slave_mode::disable);
  // External trigger filter.
  static constexpr auto ext_trig_filter = option::get<timer::ext_trig_filter, _args...>(
                                            timer::ext_trig_filter::disable);
  // External trigger prescaler.
  static constexpr auto ext_trig_div = option::get<timer::ext_trig_div, _args...>(
                                         timer::ext_trig_div::_1);
  // External clock enable.
  static constexpr auto ext_clock = option::get<timer::ext_clock, _args...>(timer::ext_clock::
                                                                            disable);
  // External trigger polarity.
  static constexpr auto ext_trig_polarity = option::get<timer::ext_trig_polarity, _args...>(
                                              timer::ext_trig_polarity::high);
  // Enabled events.
  static constexpr auto events = option::get<timer::events, _args...>(timer::events(0));
  // DMA burst length.
  static constexpr auto dma_burst_length = option::get<timer::dma_burst_length, _args...>(
                                             timer::dma_burst_length::_1);
  // Initial register for DMA burst.
  static constexpr auto dma_base_address = option::get<timer::dma_base_address_gp, _args...>(
                                             timer::dma_base_address_gp::cr1);
  // Enable global irq.
  static constexpr auto irq = option::get<timer::irq, _args...>();

  static_assert(option::check<
    std::tuple<
      timer::id,
      timer::update_request_src,
      timer::update,
      timer::one_pulse,
      timer::direction,
      timer::center_align,
      timer::auto_reload,
      timer::dtg_df_div,
      timer::counter,
      timer::dma_trig,
      timer::master_mode,
      timer::ti1_mux,
      timer::slave_mode,
      timer::slave_trig_sel,
      timer::master_slave_mode,
      timer::ext_trig_filter,
      timer::ext_trig_div,
      timer::ext_clock,
      timer::ext_trig_polarity,
      timer::events,
      timer::dma_burst_length,
      timer::dma_base_address_gp,
      timer::irq
    >,
    _args...
  >());
};

/**
 * Timers 6, 7 config
*/
template<auto ..._args>
struct _dev<id::tim6, _args...>
{
  static constexpr auto id = timer::id::tim6;
};

/**
 * Timers 9, 12 config
*/
template<auto ..._args>
struct _dev<id::tim9, _args...>
{
  static constexpr auto id = timer::id::tim9;
};

/**
 * Timers 10, 11, 13, 14 config
*/
template<auto ..._args>
struct _dev<id::tim10, _args...>
{
  static constexpr auto id = timer::id::tim10;
};

/**
 * Timers 1, 8, 2, 3, 4, 5 input channel config
*/
template<auto ..._args>
struct _input<id::tim1, _args...>
{
  static constexpr auto dev_class = lmcu::dev_class::timer_in_channel;

  static constexpr auto id = timer::id::tim1;

  // Channel number.
  static constexpr auto channel = option::get<timer::channel, _args...>();
  // Channel enable.
  static constexpr auto channel_en = option::get<timer::channel_en, _args...>(timer::channel_en::
                                                                              disable);
  // Input channel mode.
  static constexpr auto in_mode = option::get<timer::in_mode, _args...>
  (
    []
    {
      switch(channel)
      {
      case timer::channel::_1: return timer::in_mode::ti1;
      case timer::channel::_2: return timer::in_mode::ti2;
      case timer::channel::_3: return timer::in_mode::ti3;
      default:                 return timer::in_mode::ti4;
      };
    }()
  );
  // Input capture prescaler.
  static constexpr auto in_div = option::get<timer::in_div, _args...>(timer::in_div::_1);
  // Input capture filter.
  static constexpr auto in_filter = option::get<timer::in_filter, _args...>(timer::in_filter::
                                                                            disable);
  // Input channel polarity.
  static constexpr auto channel_polarity = option::get<timer::channel_polarity, _args...>(
                                             timer::channel_polarity::direct);

  static_assert(!option::is_null<channel>());

  static_assert(option::check<
    std::tuple<
      timer::id,
      timer::channel,
      timer::channel_en,
      timer::in_mode,
      timer::in_div,
      timer::in_filter,
      timer::channel_polarity
    >,
    _args...
  >());
};

/**
 * Timers 1, 8 output channel config
*/
template<auto ..._args>
struct _output<id::tim1, _args...>
{
  static constexpr auto dev_class = lmcu::dev_class::timer_out_channel;

  static constexpr auto id = timer::id::tim1;

  // Channel number.
  static constexpr auto channel = option::get<timer::channel, _args...>();
  // Channel enable.
  static constexpr auto channel_en = option::get<timer::channel_en, _args...>(timer::channel_en::
                                                                              disable);
  // Output Compare polarity.
  static constexpr auto channel_polarity = option::get<timer::channel_polarity, _args...>(
                                             timer::channel_polarity::direct);
  // N channel output enable.
  static constexpr auto channel_n_en = option::get<timer::channel_n_en, _args...>(
                                         timer::channel_n_en::disable);
  // N channel Output Compare polarity.
  static constexpr auto channel_n_polarity = option::get<timer::channel_n_polarity, _args...>(
                                               timer::channel_n_polarity::direct);
  // Output idle state.
  static constexpr auto out_idle = option::get<timer::out_idle, _args...>(timer::out_idle::low);
  // Output idle state (on inverted channel).
  static constexpr auto out_n_idle = option::get<timer::out_n_idle, _args...>(timer::out_n_idle::
                                                                              low);
  // Output Compare fast enable.
  static constexpr auto out_fast = option::get<timer::out_fast, _args...>(timer::out_fast::
                                                                          disable);
  // Output Compare preload enable.
  static constexpr auto out_preload = option::get<timer::out_preload, _args...>(timer::out_preload::
                                                                                disable);
  // Output Compare mode.
  static constexpr auto out_mode = option::get<timer::out_mode, _args...>(timer::out_mode::
                                                                          frozen);
  // Output Compare clear (OCRef cleared as soon as a High level is detected on ETRF input).
  static constexpr auto out_clear = option::get<timer::out_clear, _args...>(timer::out_clear::
                                                                            disable);

  static_assert(!option::is_null<channel>());

  static_assert(option::check<
    std::tuple<
      timer::id,
      timer::channel,
      timer::channel_en,
      timer::channel_polarity,
      timer::channel_n_en,
      timer::channel_n_polarity,
      timer::out_idle,
      timer::out_n_idle,
      timer::out_fast,
      timer::out_preload,
      timer::out_mode,
      timer::out_clear
    >,
    _args...
  >());
};

/**
 * Timers 2, 3, 4, 5 output channel config
*/
template<auto ..._args>
struct _output<id::tim2, _args...>
{
  static constexpr auto dev_class = lmcu::dev_class::timer_out_channel;

  static constexpr auto id = timer::id::tim2;

  // Channel number.
  static constexpr auto channel = option::get<timer::channel, _args...>();
  // Channel enable.
  static constexpr auto channel_en = option::get<timer::channel_en, _args...>(timer::channel_en::
                                                                              disable);
  // Output Compare polarity.
  static constexpr auto channel_polarity = option::get<timer::channel_polarity, _args...>(
                                             timer::channel_polarity::direct);
  // Output Compare fast enable.
  static constexpr auto out_fast = option::get<timer::out_fast, _args...>(timer::out_fast::
                                                                          disable);
  // Output Compare preload enable.
  static constexpr auto out_preload = option::get<timer::out_preload, _args...>(timer::out_preload::
                                                                                disable);
  // Output Compare mode.
  static constexpr auto out_mode = option::get<timer::out_mode, _args...>(timer::out_mode::
                                                                          frozen);
  // Output Compare clear (OCRef cleared as soon as a High level is detected on ETRF input).
  static constexpr auto out_clear = option::get<timer::out_clear, _args...>(timer::out_clear::
                                                                            disable);

  static_assert(!option::is_null<channel>());

  static_assert(option::check<
    std::tuple<
      timer::id,
      timer::channel,
      timer::channel_en,
      timer::channel_polarity,
      timer::out_fast,
      timer::out_preload,
      timer::out_mode,
      timer::out_clear
    >,
    _args...
  >());
};

template<auto ..._args>
struct _dev<id::tim8, _args...> : _dev<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim8; };

template<auto ..._args>
struct _dev<id::tim3, _args...> : _dev<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim3; };

template<auto ..._args>
struct _dev<id::tim4, _args...> : _dev<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim4; };

template<auto ..._args>
struct _dev<id::tim5, _args...> : _dev<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim5; };

template<auto ..._args>
struct _dev<id::tim7, _args...> : _dev<id::tim6, _args...>
{ static constexpr auto id = timer::id::tim7; };

template<auto ..._args>
struct _dev<id::tim12, _args...> : _dev<id::tim9, _args...>
{ static constexpr auto id = timer::id::tim12; };

template<auto ..._args>
struct _dev<id::tim11, _args...> : _dev<id::tim10, _args...>
{ static constexpr auto id = timer::id::tim11; };

template<auto ..._args>
struct _dev<id::tim13, _args...> : _dev<id::tim10, _args...>
{ static constexpr auto id = timer::id::tim13; };

template<auto ..._args>
struct _dev<id::tim14, _args...> : _dev<id::tim10, _args...>
{ static constexpr auto id = timer::id::tim14; };

template<auto ..._args>
struct _input<id::tim8, _args...> : _input<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim8; };

template<auto ..._args>
struct _input<id::tim2, _args...> : _input<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim2; };

template<auto ..._args>
struct _input<id::tim3, _args...> : _input<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim3; };

template<auto ..._args>
struct _input<id::tim4, _args...> : _input<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim4; };

template<auto ..._args>
struct _input<id::tim5, _args...> : _input<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim5; };

template<auto ..._args>
struct _output<id::tim8, _args...> : _output<id::tim1, _args...>
{ static constexpr auto id = timer::id::tim8; };

template<auto ..._args>
struct _output<id::tim3, _args...> : _output<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim3; };

template<auto ..._args>
struct _output<id::tim4, _args...> : _output<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim4; };

template<auto ..._args>
struct _output<id::tim5, _args...> : _output<id::tim2, _args...>
{ static constexpr auto id = timer::id::tim5; };

template<auto ..._args>
using dev = _dev<option::get<timer::id, _args...>(), _args...>;

template<auto ..._args>
using input = _input<option::get<timer::id, _args...>(), _args...>;

template<auto ..._args>
using output = _output<option::get<timer::id, _args...>(), _args...>;

// ------------------------------------------------------------------------------------------------

namespace detail {

enum class tim_irqn
{
  tim1_brk,
  tim1_up,
  tim1_trg_com,
  tim1_cc,

  tim2_global,
  tim3_global,
  tim4_global,
  tim5_global,
  tim6_global,
  tim7_global,

  tim8_brk,
  tim8_up,
  tim8_trg_com,
  tim8_cc,

  tim9_global,
  tim10_global,
  tim11_global,
  tim12_global,
  tim13_global,
  tim14_global
};

template<tim_irqn>
struct irqn_wrap { using type = device::irqn; };

template<tim_irqn _irqn>
constexpr device::irqn irqn_v() noexcept
{
  using irqn = typename irqn_wrap<_irqn>::type;

  if constexpr(_irqn == tim_irqn::tim1_brk)     { return irqn::tim1_brk;     } else
  if constexpr(_irqn == tim_irqn::tim1_up)      { return irqn::tim1_up;      } else
  if constexpr(_irqn == tim_irqn::tim1_trg_com) { return irqn::tim1_trg_com; } else
  if constexpr(_irqn == tim_irqn::tim1_cc)      { return irqn::tim1_cc;      } else
  if constexpr(_irqn == tim_irqn::tim2_global)  { return irqn::tim2;         } else
  if constexpr(_irqn == tim_irqn::tim3_global)  { return irqn::tim3;         } else
  if constexpr(_irqn == tim_irqn::tim4_global)  { return irqn::tim4;         } else
  if constexpr(_irqn == tim_irqn::tim5_global)  { return irqn::tim5;         } else
  if constexpr(_irqn == tim_irqn::tim6_global)  { return irqn::tim6;         } else
  if constexpr(_irqn == tim_irqn::tim7_global)  { return irqn::tim7;         } else
  if constexpr(_irqn == tim_irqn::tim8_brk)     { return irqn::tim8_brk;     } else
  if constexpr(_irqn == tim_irqn::tim8_up)      { return irqn::tim8_up;      } else
  if constexpr(_irqn == tim_irqn::tim8_trg_com) { return irqn::tim8_trg_com; } else
  if constexpr(_irqn == tim_irqn::tim8_cc)      { return irqn::tim8_cc;      } else
  if constexpr(_irqn == tim_irqn::tim9_global)  { return irqn::tim9;         } else
  if constexpr(_irqn == tim_irqn::tim10_global) { return irqn::tim10;        } else
  if constexpr(_irqn == tim_irqn::tim11_global) { return irqn::tim11;        } else
  if constexpr(_irqn == tim_irqn::tim12_global) { return irqn::tim12;        } else
  if constexpr(_irqn == tim_irqn::tim13_global) { return irqn::tim13;        } else
  if constexpr(_irqn == tim_irqn::tim14_global) { return irqn::tim14;        }
}

template<id _id>
struct inst;

template<id _id>
using inst_t = typename inst<_id>::type;

template<>
struct inst<id::tim1> { using type = device::TIM1; };

template<>
struct inst<id::tim2> { using type = device::TIM2; };

template<>
struct inst<id::tim3> { using type = device::TIM3; };

template<>
struct inst<id::tim4> { using type = device::TIM4; };

template<>
struct inst<id::tim5> { using type = device::TIM5; };

template<>
struct inst<id::tim6> { using type = device::TIM6; };

template<>
struct inst<id::tim7> { using type = device::TIM7; };

template<>
struct inst<id::tim8> { using type = device::TIM8; };

template<>
struct inst<id::tim9> { using type = device::TIM9; };

template<>
struct inst<id::tim10> { using type = device::TIM10; };

template<>
struct inst<id::tim11> { using type = device::TIM11; };

template<>
struct inst<id::tim12> { using type = device::TIM12; };

template<>
struct inst<id::tim13> { using type = device::TIM13; };

template<>
struct inst<id::tim14> { using type = device::TIM14; };

template<typename _inst, typename _cfg, typename _reg>
void update_request_src_conf(_reg&& r)
{
  if constexpr(_cfg::update_request_src == update_request_src::any) {
    r &= ~_inst::CR1::URS;
  }
  else {
    r |= _inst::CR1::URS;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void update_conf(_reg&& r)
{
  if constexpr(_cfg::update == update::enable) {
    r &= ~_inst::CR1::UDIS;
  }
  else {
    r |= _inst::CR1::UDIS;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void one_pulse_conf(_reg&& r)
{
  if constexpr(_cfg::one_pulse == one_pulse::disable) {
    r &= ~_inst::CR1::OPM;
  }
  else {
    r |= _inst::CR1::OPM;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void direction_conf(_reg&& r)
{
  if constexpr(_cfg::direction == direction::up) {
    r &= ~_inst::CR1::DIR;
  }
  else {
    r |= _inst::CR1::DIR;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void center_align_conf(_reg&& r)
{
  r &= ~_inst::CR1::CMS_MASK;
  switch(_cfg::center_align)
  {
  case center_align::down:    r |= _inst::CR1::CMS_CENTER_ALIGNED_MODE1; break;
  case center_align::up:      r |= _inst::CR1::CMS_CENTER_ALIGNED_MODE2; break;
  case center_align::up_down: r |= _inst::CR1::CMS_CENTER_ALIGNED_MODE3; break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void auto_reload_conf(_reg&& r)
{
  if constexpr(_cfg::auto_reload == auto_reload::disable) {
    r &= ~_inst::CR1::ARPE;
  }
  else {
    r |= _inst::CR1::ARPE;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void dtg_df_div_conf(_reg&& r)
{
  r &= ~_inst::CR1::CKD_MASK;
  switch(_cfg::dtg_df_div)
  {
  case dtg_df_div::_2: r |= _inst::CR1::CKD_2; break;
  case dtg_df_div::_4: r |= _inst::CR1::CKD_4; break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void cc_update_conf(_reg&& r)
{
  if constexpr(_cfg::cc_update == cc_update::disable) {
    r &= ~_inst::CR2::CCPC;
  }
  else {
    r |= _inst::CR2::CCPC;
    if constexpr(_cfg::cc_update == cc_update::comg) {
      r &= ~_inst::CR2::CCUS;
    }
    else {
      r |= _inst::CR2::CCUS;
    }
  }
}

template<typename _inst, typename _cfg, typename _reg>
void dma_trig_conf(_reg&& r)
{
  if constexpr(_cfg::dma_trig == dma_trig::cc_evt) {
    r &= ~_inst::CR2::CCDS;
  }
  else {
    r |= _inst::CR2::CCDS;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void master_mode_conf(_reg&& r)
{
  r &= ~_inst::CR2::MMS_MASK;
  switch(_cfg::master_mode)
  {
  case master_mode::enable:     r |= _inst::CR2::MMS_ENABLE;        break;
  case master_mode::update:     r |= _inst::CR2::MMS_UPDATE;        break;
  case master_mode::comp_pulse: r |= _inst::CR2::MMS_COMPARE_PULSE; break;
  case master_mode::comp_1:     r |= _inst::CR2::MMS_CMP_OC1REF;    break;
  case master_mode::comp_2:     r |= _inst::CR2::MMS_CMP_OC2REF;    break;
  case master_mode::comp_3:     r |= _inst::CR2::MMS_CMP_OC3REF;    break;
  case master_mode::comp_4:     r |= _inst::CR2::MMS_CMP_OC4REF;    break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void ti1_mux_conf(_reg&& r)
{
  if constexpr(_cfg::ti1_mux == ti1_mux::ch1) {
    r &= ~_inst::CR2::TI1S;
  }
  else {
    r |= _inst::CR2::TI1S;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void slave_mode_conf(_reg&& r)
{
  r &= ~_inst::SMCR::SMS_MASK;
  switch(_cfg::slave_mode)
  {
  case slave_mode::encoder_1: r |= _inst::SMCR::SMS_ENCODER_MODE_1;        break;
  case slave_mode::encoder_2: r |= _inst::SMCR::SMS_ENCODER_MODE_2;        break;
  case slave_mode::encoder_3: r |= _inst::SMCR::SMS_ENCODER_MODE_3;        break;
  case slave_mode::reset:     r |= _inst::SMCR::SMS_RESET_MODE;            break;
  case slave_mode::gated:     r |= _inst::SMCR::SMS_GATED_MODE;            break;
  case slave_mode::trigger:   r |= _inst::SMCR::SMS_TRIGGER_MODE;          break;
  case slave_mode::ext_clock: r |= _inst::SMCR::SMS_EXTERNAL_CLOCK_MODE_1; break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void slave_trig_sel_conf(_reg&& r)
{
  r &= ~_inst::SMCR::TS_MASK;
  switch(_cfg::slave_trig_sel)
  {
  case slave_trig_sel::itr0:    r |= _inst::SMCR::TS_ITR0;    break;
  case slave_trig_sel::itr1:    r |= _inst::SMCR::TS_ITR1;    break;
  case slave_trig_sel::itr2:    r |= _inst::SMCR::TS_ITR2;    break;
  case slave_trig_sel::itr3:    r |= _inst::SMCR::TS_ITR3;    break;
  case slave_trig_sel::ti1f_ed: r |= _inst::SMCR::TS_TI1F_ED; break;
  case slave_trig_sel::ti1f_p1: r |= _inst::SMCR::TS_TI1FP1;  break;
  case slave_trig_sel::ti2f_p2: r |= _inst::SMCR::TS_TI2FP2;  break;
  case slave_trig_sel::etrf:    r |= _inst::SMCR::TS_ETRF;    break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void master_slave_mode_conf(_reg&& r)
{
  if constexpr(_cfg::master_slave_mode == master_slave_mode::enable) {
    r |= _inst::SMCR::MSM;
  }
  else {
    r &= ~_inst::SMCR::MSM;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void ext_trig_filter_conf(_reg&& r)
{
  r &= ~_inst::SMCR::ETF_MASK;
  switch(_cfg::ext_trig_filter)
  {
  case ext_trig_filter::ckint_n2: r |= _inst::SMCR::ETF_CK_INT_N2;    break;
  case ext_trig_filter::ckint_n4: r |= _inst::SMCR::ETF_CK_INT_N4;    break;
  case ext_trig_filter::ckint_n8: r |= _inst::SMCR::ETF_CK_INT_N8;    break;
  case ext_trig_filter::dts2_n6:  r |= _inst::SMCR::ETF_DTS_DIV2_N6;  break;
  case ext_trig_filter::dts2_n8:  r |= _inst::SMCR::ETF_DTS_DIV2_N8;  break;
  case ext_trig_filter::dts4_n6:  r |= _inst::SMCR::ETF_DTS_DIV4_N6;  break;
  case ext_trig_filter::dts4_n8:  r |= _inst::SMCR::ETF_DTS_DIV4_N8;  break;
  case ext_trig_filter::dts8_n6:  r |= _inst::SMCR::ETF_DTS_DIV8_N6;  break;
  case ext_trig_filter::dts8_n8:  r |= _inst::SMCR::ETF_DTS_DIV8_N8;  break;
  case ext_trig_filter::dts16_n5: r |= _inst::SMCR::ETF_DTS_DIV16_N5; break;
  case ext_trig_filter::dts16_n6: r |= _inst::SMCR::ETF_DTS_DIV16_N6; break;
  case ext_trig_filter::dts16_n8: r |= _inst::SMCR::ETF_DTS_DIV16_N8; break;
  case ext_trig_filter::dts32_n5: r |= _inst::SMCR::ETF_DTS_DIV32_N5; break;
  case ext_trig_filter::dts32_n6: r |= _inst::SMCR::ETF_DTS_DIV32_N6; break;
  case ext_trig_filter::dts32_n8: r |= _inst::SMCR::ETF_DTS_DIV32_N8; break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void ext_trig_div_conf(_reg&& r)
{
  r &= ~_inst::SMCR::ETPS_MASK;
  switch(_cfg::ext_trig_div)
  {
  case ext_trig_div::_2: r |= _inst::SMCR::ETPS_ETRP_DIV2; break;
  case ext_trig_div::_4: r |= _inst::SMCR::ETPS_ETRP_DIV4; break;
  case ext_trig_div::_8: r |= _inst::SMCR::ETPS_ETRP_DIV8; break;
  default: break;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void ext_clock_conf(_reg&& r)
{
  if constexpr(_cfg::ext_clock == ext_clock::enable) {
    r |= _inst::SMCR::ECE;
  }
  else {
    r &= ~_inst::SMCR::ECE;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void ext_trig_polarity_conf(_reg&& r)
{
  if constexpr(_cfg::ext_trig_polarity == ext_trig_polarity::low) {
    r |= _inst::SMCR::ETP;
  }
  else {
    r &= ~_inst::SMCR::ETP;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void main_output_conf(_reg&& r)
{
  if constexpr(_cfg::main_output == main_output::enable) {
    r |= _inst::BDTR::MOE;
  }
  else {
    r &= ~_inst::BDTR::MOE;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void main_auto_output_conf(_reg&& r)
{
  if constexpr(_cfg::main_auto_output == main_auto_output::enable) {
    r |= _inst::BDTR::AOE;
  }
  else {
    r &= ~_inst::BDTR::AOE;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void break_polarity_conf(_reg&& r)
{
  if constexpr(_cfg::break_polarity == break_polarity::high) {
    r |= _inst::BDTR::BKP;
  }
  else {
    r &= ~_inst::BDTR::BKP;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void break_input_conf(_reg&& r)
{
  if constexpr(_cfg::break_input == break_input::enable) {
    r |= _inst::BDTR::BKE;
  }
  else {
    r &= ~_inst::BDTR::BKE;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void off_state_run_conf(_reg&& r)
{
  if constexpr(_cfg::off_state_run == off_state_run::high) {
    r |= _inst::BDTR::OSSR;
  }
  else {
    r &= ~_inst::BDTR::OSSR;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void off_state_idle_conf(_reg&& r)
{
  if constexpr(_cfg::off_state_idle == off_state_idle::high) {
    r |= _inst::BDTR::OSSI;
  }
  else {
    r &= ~_inst::BDTR::OSSI;
  }
}

template<typename _inst, typename _cfg, typename _reg>
void lock_conf(_reg&& r)
{
  r &= ~_inst::BDTR::LOCK_MASK;
  switch(_cfg::lock)
  {
  case lock::level_1: r |= _inst::BDTR::LOCK_LEVEL_1; break;
  case lock::level_2: r |= _inst::BDTR::LOCK_LEVEL_2; break;
  case lock::level_3: r |= _inst::BDTR::LOCK_LEVEL_3; break;
  default: break;
  }
}

template<typename _inst, typename _cfg>
void dma_conf()
{
  auto r = _inst::DCR::get();

  r &= _inst::DCR::DBL_MASK | _inst::DCR::DBA_MASK;
  r |= uint32_t(_cfg::dma_burst_length) << _inst::DCR::DBL_POS;
  r |= uint32_t(_cfg::dma_base_address) << _inst::DCR::DBA_POS;

  _inst::DCR::set(r);
}

template<typename _inst, typename _cfg>
void counter_conf()
{
  if constexpr(_cfg::counter == counter::enable) { _inst::CR1::set_b(_inst::CR1::CEN); }
}

template<typename _inst, typename _cfg, typename _reg>
void channel_en_conf(_reg&& r)
{
  constexpr uint32_t cce_mask[] = { _inst::CCER::CC1E_MASK, _inst::CCER::CC2E_MASK,
                                    _inst::CCER::CC3E_MASK, _inst::CCER::CC4E_MASK };

  constexpr uint32_t cce[] = { _inst::CCER::CC1E, _inst::CCER::CC2E, _inst::CCER::CC3E,
                               _inst::CCER::CC4E };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  r &= ~cce_mask[ch_n];

  if constexpr(_cfg::channel_en == channel_en::disable) {
    r &= ~cce[ch_n];
  }
  else {
    r |= cce[ch_n];
  }
}

template<typename _inst, typename _cfg, typename _reg>
void channel_polarity_conf(_reg&& r)
{
  constexpr uint32_t ccp_mask[] = { _inst::CCER::CC1P_MASK, _inst::CCER::CC2P_MASK,
                                    _inst::CCER::CC3P_MASK, _inst::CCER::CC4P_MASK };

  constexpr uint32_t ccp[] = { _inst::CCER::CC1P, _inst::CCER::CC2P, _inst::CCER::CC3P,
                               _inst::CCER::CC4P };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  r &= ~ccp_mask[ch_n];

  if constexpr(_cfg::channel_polarity == channel_polarity::direct) {
    r &= ~ccp[ch_n];
  }
  else {
    r |= ccp[ch_n];
  }
}

template<typename _inst, typename _cfg, typename _reg>
void channel_n_en_conf(_reg&& r)
{
  [[maybe_unused]]
  constexpr uint32_t ccne[] = { _inst::CCER::CC1NE, _inst::CCER::CC2NE, _inst::CCER::CC3NE };
  constexpr uint32_t ccne_mask[] = { _inst::CCER::CC1NE_MASK, _inst::CCER::CC2NE_MASK,
                                     _inst::CCER::CC3NE_MASK };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  r &= ~ccne_mask[ch_n];

  if constexpr(ch_n < 3 && _cfg::channel_n_en == channel_n_en::enable) { r |= ccne[ch_n]; }
}

template<typename _inst, typename _cfg, typename _reg>
void channel_n_polarity_conf(_reg&& r)
{
  [[maybe_unused]]
  constexpr uint32_t ccnp[] = { _inst::CCER::CC1NP, _inst::CCER::CC2NP, _inst::CCER::CC3NP };

  constexpr uint32_t ccnp_mask[] = { _inst::CCER::CC1NP_MASK, _inst::CCER::CC2NP_MASK,
                                     _inst::CCER::CC3NP_MASK };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  r &= ~ccnp_mask[ch_n];

  if constexpr(ch_n < 3 && _cfg::channel_n_polarity == channel_n_polarity::inverted) {
    r |= ccnp[ch_n];
  }
}

template<typename _inst, typename _cfg, typename _reg>
void out_idle_conf(_reg&& r)
{
  constexpr uint32_t ois[] = {_inst::CR2::OIS1, _inst::CR2::OIS2, _inst::CR2::OIS3,
                              _inst::CR2::OIS4 };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  if constexpr(_cfg::out_idle == out_idle::low) {
    r &= ~ois[ch_n];
  }
  else {
    r |= ois[ch_n];
  }
}

template<typename _inst, typename _cfg, typename _reg>
void out_n_idle_conf(_reg&& r)
{
  constexpr uint32_t ois_n[] = { _inst::CR2::OIS1N, _inst::CR2::OIS2N, _inst::CR2::OIS3N };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  if constexpr(ch_n < 3) {
    if constexpr(_cfg::out_n_idle == out_n_idle::low) {
      r &= ~ois_n[ch_n];
    }
    else {
      r |= ois_n[ch_n];
    }
  }
}

template<typename _inst, typename _cfg>
void out_mode_conf()
{
  constexpr uint32_t ccmr_mask[] = {
    _inst::CCMR1::CC1S_MASK | _inst::CCMR1::OC1FE_MASK | _inst::CCMR1::OC1PE_MASK |
    _inst::CCMR1::OC1M_MASK | _inst::CCMR1::OC1CE,

    _inst::CCMR1::CC2S_MASK | _inst::CCMR1::OC2FE_MASK | _inst::CCMR1::OC2PE_MASK |
    _inst::CCMR1::OC2M_MASK | _inst::CCMR1::OC2CE,

    _inst::CCMR2::CC3S_MASK | _inst::CCMR2::OC3FE_MASK | _inst::CCMR2::OC3PE_MASK |
    _inst::CCMR2::OC3M_MASK | _inst::CCMR2::OC3CE,

    _inst::CCMR2::CC4S_MASK | _inst::CCMR2::OC4FE_MASK | _inst::CCMR2::OC4PE_MASK |
    _inst::CCMR2::OC4M_MASK | _inst::CCMR2::OC4CE
  };

  constexpr auto ch_n = uint32_t(_cfg::channel);

  uint32_t r;

  if constexpr(ch_n <= 1) {
    r = _inst::CCMR1::get();
  }
  else {
    r = _inst::CCMR2::get();
  }

  r &= ~ccmr_mask[ch_n];

  constexpr bool _1 = ch_n % 2 == 0;

  if(_cfg::out_fast == out_fast::enable) {
    r |= _1? _inst::CCMR1::OC1FE : _inst::CCMR1::OC2FE;
  }

  if(_cfg::out_preload == out_preload::enable) {
    r |= _1? _inst::CCMR1::OC1PE : _inst::CCMR1::OC2PE;
  }

  switch(_cfg::out_mode)
  {
  case out_mode::active_on_match:
    r |= _1? _inst::CCMR1::OC1M_ACTIVE : _inst::CCMR1::OC2M_ACTIVE;
    break;
  case out_mode::inactive_on_match:
    r |= _1? _inst::CCMR1::OC1M_INACTIVE : _inst::CCMR1::OC2M_INACTIVE;
    break;
  case out_mode::toggle:
    r |= _1? _inst::CCMR1::OC1M_TOGGLE : _inst::CCMR1::OC2M_TOGGLE;
    break;
  case out_mode::force_inactive:
    r |= _1? _inst::CCMR1::OC1M_FORCE_INACTIVE : _inst::CCMR1::OC2M_FORCE_INACTIVE;
    break;
  case out_mode::force_active:
    r |= _1? _inst::CCMR1::OC1M_FORCE_ACTIVE : _inst::CCMR1::OC2M_FORCE_ACTIVE;
    break;
  case out_mode::pwm_1:
    r |= _1? _inst::CCMR1::OC1M_PWM_MODE_1 : _inst::CCMR1::OC2M_PWM_MODE_1;
    break;
  case out_mode::pwm_2:
    r |= _1? _inst::CCMR1::OC1M_PWM_MODE_2 : _inst::CCMR1::OC2M_PWM_MODE_2;
    break;
  default: break;
  }

  if constexpr(_cfg::out_clear == out_clear::enable) {
    r |= _1? _inst::CCMR1::OC1CE : _inst::CCMR1::OC2CE;
  }

  if constexpr(ch_n <= 1) {
    _inst::CCMR1::set(r);
  }
  else {
    _inst::CCMR2::set(r);
  }
}

template<typename _cfg>
void configure_tim_1_8()
{
  using namespace detail;

  using inst = inst_t<_cfg::id>;

  uint32_t r;

  // Disable counter
  inst::CR1::clr_b(inst::CR1::CEN);

  r = inst::CR1::get();

  update_request_src_conf<inst, _cfg>(r);
  update_conf<inst, _cfg>(r);
  one_pulse_conf<inst, _cfg>(r);
  direction_conf<inst, _cfg>(r);
  center_align_conf<inst, _cfg>(r);
  auto_reload_conf<inst, _cfg>(r);
  dtg_df_div_conf<inst, _cfg>(r);

  inst::CR1::set(r);

  r = inst::CR2::get();

  cc_update_conf<inst, _cfg>(r);
  dma_trig_conf<inst, _cfg>(r);
  master_mode_conf<inst, _cfg>(r);
  ti1_mux_conf<inst, _cfg>(r);

  inst::CR2::set(r);

  inst::SMCR::set(0);
  if constexpr(_cfg::slave_mode != timer::slave_mode::disable) {
    r = 0;

    slave_trig_sel_conf<inst, _cfg>(r);
    slave_mode_conf<inst, _cfg>(r);
    master_slave_mode_conf<inst, _cfg>(r);
    ext_trig_filter_conf<inst, _cfg>(r);
    ext_trig_div_conf<inst, _cfg>(r);
    ext_clock_conf<inst, _cfg>(r);
    ext_trig_polarity_conf<inst, _cfg>(r);

    inst::SMCR::set(r);
  }

  inst::DIER::set(flags::value(_cfg::events));

  r = inst::BDTR::get();

  main_output_conf<inst, _cfg>(r);
  main_auto_output_conf<inst, _cfg>(r);
  break_polarity_conf<inst, _cfg>(r);
  break_input_conf<inst, _cfg>(r);
  off_state_run_conf<inst, _cfg>(r);
  lock_conf<inst, _cfg>(r);

  inst::BDTR::set(r);

  dma_conf<inst, _cfg>();

  constexpr auto brk_irqn = (_cfg::id == timer::id::tim1)? irqn_v<tim_irqn::tim1_brk>() :
                                                           irqn_v<tim_irqn::tim8_brk>();
  if constexpr(!option::is_null<_cfg::brk_irq>()) {
    nvic::set_priority<brk_irqn, _cfg::brk_irq>();
    nvic::enable_irq<brk_irqn>();
  }
  else {
    nvic::disable_irq<brk_irqn>();
  }

  constexpr auto up_irqn = (_cfg::id == timer::id::tim1)? irqn_v<tim_irqn::tim1_up>() :
                                                          irqn_v<tim_irqn::tim8_up>();
  if constexpr(!option::is_null<_cfg::up_irq>()) {
    nvic::set_priority<up_irqn, _cfg::up_irq>();
    nvic::enable_irq<up_irqn>();
  }
  else {
    nvic::disable_irq<up_irqn>();
  }

  constexpr auto trg_com_irqn = (_cfg::id == timer::id::tim1)? irqn_v<tim_irqn::tim1_trg_com>() :
                                                               irqn_v<tim_irqn::tim8_trg_com>();
  if constexpr(!option::is_null<_cfg::trg_com_irq>()) {
    nvic::set_priority<trg_com_irqn, _cfg::trg_com_irq>();
    nvic::enable_irq<trg_com_irqn>();
  }
  else {
    nvic::disable_irq<trg_com_irqn>();
  }

  constexpr auto cc_irqn = (_cfg::id == timer::id::tim1)? irqn_v<tim_irqn::tim1_cc>() :
                                                          irqn_v<tim_irqn::tim8_cc>();
  if constexpr(!option::is_null<_cfg::cc_irq>()) {
    nvic::set_priority<cc_irqn, _cfg::cc_irq>();
    nvic::enable_irq<cc_irqn>();
  }
  else {
    nvic::disable_irq<cc_irqn>();
  }

  counter_conf<inst, _cfg>();
}

template<typename _cfg>
void configure_tim_2_3_4_5()
{
  using namespace detail;

  using inst = inst_t<_cfg::id>;

  uint32_t r;

  // Disable counter
  inst::CR1::clr_b(inst::CR1::CEN);

  r = inst::CR1::get();

  update_request_src_conf<inst, _cfg>(r);
  update_conf<inst, _cfg>(r);
  one_pulse_conf<inst, _cfg>(r);
  direction_conf<inst, _cfg>(r);
  center_align_conf<inst, _cfg>(r);
  auto_reload_conf<inst, _cfg>(r);
  dtg_df_div_conf<inst, _cfg>(r);

  inst::CR1::set(r);

  r = inst::CR2::get();

  dma_trig_conf<inst, _cfg>(r);
  master_mode_conf<inst, _cfg>(r);
  ti1_mux_conf<inst, _cfg>(r);

  inst::CR2::set(r);

  inst::SMCR::set(0);
  if constexpr(_cfg::slave_mode != timer::slave_mode::disable) {
    r = 0;

    slave_trig_sel_conf<inst, _cfg>(r);
    slave_mode_conf<inst, _cfg>(r);
    master_slave_mode_conf<inst, _cfg>(r);
    ext_trig_filter_conf<inst, _cfg>(r);
    ext_trig_div_conf<inst, _cfg>(r);
    ext_clock_conf<inst, _cfg>(r);
    ext_trig_polarity_conf<inst, _cfg>(r);

    inst::SMCR::set(r);
  }

  static_assert(flags::none(_cfg::events, events::comi, events::bi, events::comd),
                "This events does not supported by timer");

  inst::DIER::set(flags::value(_cfg::events));

  dma_conf<inst, _cfg>();

  constexpr auto irqn = []
  {
    switch(_cfg::id)
    {
    case id::tim2: return irqn_v<tim_irqn::tim2_global>();
    case id::tim3: return irqn_v<tim_irqn::tim3_global>();
    case id::tim4: return irqn_v<tim_irqn::tim4_global>();
    default:       return irqn_v<tim_irqn::tim5_global>();
    }
  }();

  if constexpr(!option::is_null<_cfg::irq>()) {
    nvic::set_priority<irqn, _cfg::irq>();
    nvic::enable_irq<irqn>();
  }
  else {
    nvic::disable_irq<irqn>();
  }

  counter_conf<inst, _cfg>();
}

template<typename _cfg>
void configure_tim_6_7()
{
}

template<typename _cfg>
void configure_tim_9_12()
{
  using namespace detail;

  using inst = inst_t<_cfg::id>;

  uint32_t r;

  // Disable counter
  inst::CR1::clr_b(inst::CR1::CEN);

  r = inst::CR1::get();

  update_request_src_conf<inst, _cfg>(r);
  update_conf<inst, _cfg>(r);
  one_pulse_conf<inst, _cfg>(r);
  auto_reload_conf<inst, _cfg>(r);
  dtg_df_div_conf<inst, _cfg>(r);

  inst::CR1::set(r);

  inst::SMCR::set(0);
  if constexpr(_cfg::slave_mode != timer::slave_mode::disable) {
    r = 0;

    slave_trig_sel_conf<inst, _cfg>(r);
    slave_mode_conf<inst, _cfg>(r);

    inst::SMCR::set(r);
  }

  static_assert(
    flags::none(_cfg::events, events::cc3i, events::cc4i, events::comi, events::bi, events::ud,
                              events::cc1d, events::cc2d, events::cc3d, events::cc4d, events::comd,
                              events::comd),
    "This events does not supported by timer"
  );
  inst::DIER::set(flags::value(_cfg::events));

  constexpr auto irqn = irqn_v<_cfg::id == id::tim9? tim_irqn::tim9_global :
                                                     tim_irqn::tim12_global>();

  if constexpr(!option::is_null<_cfg::irq>()) {
    nvic::set_priority<irqn, _cfg::irq>();
    nvic::enable_irq<irqn>();
  }
  else {
    nvic::disable_irq<irqn>();
  }

  counter_conf<inst, _cfg>();
}

template<typename _cfg>
void configure_tim_10_11_13_14()
{
}

template<typename _cfg>
void configure_tim_1_8_2_3_4_5_in_channel()
{
  using inst = inst_t<_cfg::id>;

  constexpr auto ch_n = uint32_t(_cfg::channel);

  {
    constexpr uint32_t ccmr_mask[] = {
      inst::CCMR1::CC1S_MASK | inst::CCMR1::IC1PSC_MASK | inst::CCMR1::IC1F_MASK,
      inst::CCMR1::CC2S_MASK | inst::CCMR1::IC2PSC_MASK | inst::CCMR1::IC2F_MASK,
      inst::CCMR2::CC3S_MASK | inst::CCMR2::IC3PSC_MASK | inst::CCMR2::IC3F_MASK,
      inst::CCMR2::CC4S_MASK | inst::CCMR2::IC4PSC_MASK | inst::CCMR2::IC4F_MASK
    };

    uint32_t r;

    if constexpr(ch_n <= 1) {
      r = inst::CCMR1::get();
    }
    else {
      r = inst::CCMR2::get();
    }

    r &= ~ccmr_mask[ch_n];

    constexpr bool _1 = ch_n % 2 == 0;

    if constexpr(_cfg::in_mode == in_mode::trc) {
      r |= _1? inst::CCMR1::CC1S_INPUT_TRC : inst::CCMR1::CC2S_INPUT_TRC;
    }
    else {
      switch(_cfg::channel)
      {
      case channel::_1:
        r |= _cfg::in_mode == in_mode::ti1? inst::CCMR1::CC1S_INPUT_TI1 :
                                            inst::CCMR1::CC1S_INPUT_TI2;
        break;
      case channel::_2:
        r |= _cfg::in_mode == in_mode::ti1? inst::CCMR1::CC2S_INPUT_TI1 :
                                            inst::CCMR1::CC2S_INPUT_TI2;
        break;
      case channel::_3:
        r |= _cfg::in_mode == in_mode::ti3? inst::CCMR2::CC3S_INPUT_TI3 :
                                            inst::CCMR2::CC3S_INPUT_TI4;
        break;
      default:
        r |= _cfg::in_mode == in_mode::ti3? inst::CCMR2::CC4S_INPUT_TI3 :
                                            inst::CCMR2::CC4S_INPUT_TI4;
        break;
      }
    }

    r |= uint32_t(_cfg::in_div) << (_1? inst::CCMR1::IC1PSC_POS : inst::CCMR1::IC2PSC_POS);

    r |= uint32_t(_cfg::in_filter) << (_1? inst::CCMR1::IC1F_POS : inst::CCMR1::IC2F_POS);

    if constexpr(ch_n <= 1) {
      inst::CCMR1::set(r);
    }
    else {
      inst::CCMR2::set(r);
    }
  }

  auto r = inst::CCER::get();

  channel_polarity_conf<inst, _cfg>(r);
  channel_en_conf<inst, _cfg>(r);

  inst::CCER::set(r);
}

template<typename _cfg>
void configure_tim_1_8_out_channel()
{
  using inst = inst_t<_cfg::id>;

  uint32_t r;

  r = inst::CR2::get();

  out_idle_conf<inst, _cfg>(r);
  out_n_idle_conf<inst, _cfg>(r);

  inst::CR2::set(r);

  out_mode_conf<inst, _cfg>();

  r = inst::CCER::get();

  channel_en_conf<inst, _cfg>(r);
  channel_polarity_conf<inst, _cfg>(r);
  channel_n_en_conf<inst, _cfg>(r);
  channel_n_polarity_conf<inst, _cfg>(r);

  inst::CCER::set(r);
}

template<typename _cfg>
void configure_tim_2_3_4_5_out_channel()
{
  using inst = inst_t<_cfg::id>;

  uint32_t r;

  out_mode_conf<inst, _cfg>();

  r = inst::CCER::get();

  channel_en_conf<inst, _cfg>(r);
  channel_polarity_conf<inst, _cfg>(r);

  inst::CCER::set(r);
}

} // namespace detail

// ------------------------------------------------------------------------------------------------

/**
 * @brief Enable clock on timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void on()
{
  using namespace device;

  auto _on = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:  RCC::APB2ENR::set_b(RCC::APB2ENR::TIM1EN);  break;
    case id::tim2:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM2EN);  break;
    case id::tim3:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM3EN);  break;
    case id::tim4:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM4EN);  break;
    case id::tim5:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM5EN);  break;
    case id::tim6:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM6EN);  break;
    case id::tim7:  RCC::APB1ENR::set_b(RCC::APB1ENR::TIM7EN);  break;
    case id::tim8:  RCC::APB2ENR::set_b(RCC::APB2ENR::TIM8EN);  break;
    case id::tim9:  RCC::APB2ENR::set_b(RCC::APB2ENR::TIM9EN);  break;
    case id::tim10: RCC::APB2ENR::set_b(RCC::APB2ENR::TIM10EN); break;
    case id::tim11: RCC::APB2ENR::set_b(RCC::APB2ENR::TIM11EN); break;
    case id::tim12: RCC::APB1ENR::set_b(RCC::APB1ENR::TIM12EN); break;
    case id::tim13: RCC::APB1ENR::set_b(RCC::APB1ENR::TIM13EN); break;
    case id::tim14: RCC::APB1ENR::set_b(RCC::APB1ENR::TIM14EN); break;
    default: break;
    }
  };

  (_on(_ids), ...);
}

/**
 * @brief Disable clock on timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void off()
{
  using namespace device;

  auto _off = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:  RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM1EN);  break;
    case id::tim2:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM2EN);  break;
    case id::tim3:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM3EN);  break;
    case id::tim4:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM4EN);  break;
    case id::tim5:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM5EN);  break;
    case id::tim6:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM6EN);  break;
    case id::tim7:  RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM7EN);  break;
    case id::tim8:  RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM8EN);  break;
    case id::tim9:  RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM9EN);  break;
    case id::tim10: RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM10EN); break;
    case id::tim11: RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM11EN); break;
    case id::tim12: RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM12EN); break;
    case id::tim13: RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM13EN); break;
    case id::tim14: RCC::APB1ENR::clr_b(RCC::APB1ENR::TIM14EN); break;
    default: break;
    }
  };

  (_off(_ids), ...);
}

/**
 * @brief Reset timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void reset()
{
  using namespace device;

  auto _rst = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM1RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM1RST);
      break;
    case id::tim2:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM2RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM2RST);
      break;
    case id::tim3:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM3RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM3RST);
      break;
    case id::tim4:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM4RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM4RST);
      break;
    case id::tim5:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM5RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM5RST);
      break;
    case id::tim6:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM6RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM6RST);
      break;
    case id::tim7:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM7RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM7RST);
      break;
    case id::tim8:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM8RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM8RST);
      break;
    case id::tim9:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM9RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM9RST);
      break;
    case id::tim10:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM10RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM10RST);
      break;
    case id::tim11:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM11RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM11RST);
      break;
    case id::tim12:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM12RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM12RST);
      break;
    case id::tim13:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM13RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM13RST);
      break;
    case id::tim14:
      RCC::APB1RSTR::set_b(RCC::APB1RSTR::TIM14RST);
      RCC::APB1RSTR::clr_b(RCC::APB1RSTR::TIM14RST);
      break;
    default: break;
    }
  };

  (_rst(_ids), ...);
}

template<typename ..._devices>
void configure()
{
  static auto _do = [](auto dev)
  {
    using cfg = decltype(dev);

    static_assert(
      cfg::dev_class == dev_class::timer ||
      cfg::dev_class == dev_class::timer_in_channel ||
      cfg::dev_class == dev_class::timer_out_channel
    );

    if constexpr(cfg::dev_class == dev_class::timer) {
      if constexpr(cfg::id == id::tim1 || cfg::id == id::tim8) {
        detail::configure_tim_1_8<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim2 || cfg::id == id::tim3 || cfg::id == id::tim4 ||
                   cfg::id == id::tim5) {
        detail::configure_tim_2_3_4_5<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim6 || cfg::id == id::tim7) {
        detail::configure_tim_6_7<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim9 || cfg::id == id::tim12) {
        detail::configure_tim_9_12<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim10 || cfg::id == id::tim11 || cfg::id == id::tim13 ||
                   cfg::id == id::tim14) {
        detail::configure_tim_10_11_13_14<cfg>();
      }
    }
    else
    if constexpr(cfg::dev_class == dev_class::timer_in_channel) {
      static_assert(cfg::id != id::tim6 && cfg::id != id::tim7, "Basic timers does not have input "
                                                                "channels");

      if constexpr(cfg::id == id::tim1 || cfg::id == id::tim8 || cfg::id == id::tim2 ||
                   cfg::id == id::tim3 || cfg::id == id::tim4 || cfg::id == id::tim5) {
        detail::configure_tim_1_8_2_3_4_5_in_channel<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim9 || cfg::id == id::tim12) {
      }
      else
      if constexpr(cfg::id == id::tim10 || cfg::id == id::tim11 || cfg::id == id::tim13 ||
                   cfg::id == id::tim14) {
      }
    }
    else
    if constexpr(cfg::dev_class == dev_class::timer_out_channel) {
      static_assert(cfg::id != id::tim6 && cfg::id != id::tim7, "Basic timers does not have output "
                                                                "channels");

      if constexpr(cfg::id == id::tim1 || cfg::id == id::tim8) {
        detail::configure_tim_1_8_out_channel<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim2 || cfg::id == id::tim3 || cfg::id == id::tim4 ||
                   cfg::id == id::tim5) {
        detail::configure_tim_2_3_4_5_out_channel<cfg>();
      }
      else
      if constexpr(cfg::id == id::tim9 || cfg::id == id::tim12) {
      }
      else
      if constexpr(cfg::id == id::tim10 || cfg::id == id::tim11 || cfg::id == id::tim13 ||
                   cfg::id == id::tim14) {
      }
    }
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Enable/disable counter
 *
 * @param en - true = enable, false = disable
*/
template<typename ..._devices>
lmcu_static_inline void counter_enable(bool en)
{
  auto _do = [&en](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    if(en) {
      inst::CR1::set_b(inst::CR1::CEN);
    }
    else {
      inst::CR1::clr_b(inst::CR1::CEN);
    }
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Read event flags
*/
template<typename _device>
lmcu_static_inline events get_events()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return flags::from_value<timer::events>(inst::SR);
}

/**
 * @brief Clear event flags
*/
template<typename ..._devices>
lmcu_static_inline void clr_events(timer::events evt)
{
  auto _do = [&evt](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::SR::set((~flags::value(evt)) & 0x1fff);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Generate events
*/
template<typename ..._devices>
lmcu_static_inline void gen_events(timer::events evt)
{
  auto _do = [&evt](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    uint32_t r = 0;

    if(flags::all(evt, events::ui)) { r |= inst::EGR::UG;   }

    if constexpr(cfg::id == id::tim1 || cfg::id == id::tim8) {
      if(flags::all(evt, events::cc1i)) { r |= inst::EGR::CC1G; }
      if(flags::all(evt, events::cc2i)) { r |= inst::EGR::CC2G; }
      if(flags::all(evt, events::cc3i)) { r |= inst::EGR::CC3G; }
      if(flags::all(evt, events::cc4i)) { r |= inst::EGR::CC4G; }
      if(flags::all(evt, events::comi)) { r |= inst::EGR::COMG; }
      if(flags::all(evt, events::ti))   { r |= inst::EGR::TG;   }
      if(flags::all(evt, events::bi))   { r |= inst::EGR::BG;   }
    }
    else
    if constexpr(cfg::id == id::tim2 || cfg::id == id::tim3 || cfg::id == id::tim4 ||
                 cfg::id == id::tim5) {
      if(flags::all(evt, events::cc1i)) { r |= inst::EGR::CC1G; }
      if(flags::all(evt, events::cc2i)) { r |= inst::EGR::CC2G; }
      if(flags::all(evt, events::cc3i)) { r |= inst::EGR::CC3G; }
      if(flags::all(evt, events::cc4i)) { r |= inst::EGR::CC4G; }
      if(flags::all(evt, events::ti))   { r |= inst::EGR::TG;   }
    }
    else
    if constexpr(cfg::id == id::tim9 || cfg::id == id::tim12) {
      if(flags::all(evt, events::cc1i)) { r |= inst::EGR::CC1G; }
      if(flags::all(evt, events::cc2i)) { r |= inst::EGR::CC2G; }
      if(flags::all(evt, events::ti))   { r |= inst::EGR::TG;   }
    }
    else
    if constexpr(cfg::id == id::tim10 || cfg::id == id::tim11 || cfg::id == id::tim13 ||
                 cfg::id == id::tim14) {
      if(flags::all(evt, events::cc1i)) { r |= inst::EGR::CC1G; }
    }

    inst::EGR::set(r);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns the current counter value.
*/
template<typename _device>
lmcu_static_inline uint16_t get_counter()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::CNT::get();
}

/**
 * @brief Set counter value.
 *
 * @param val - counter value.
*/
template<typename ..._devices>
lmcu_static_inline void set_counter(uint16_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::CNT::set(val);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns current prescaler value.
*/
template<typename _device>
lmcu_static_inline uint16_t get_prescaler()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::PSC::get();
}

/**
 * @brief Set prescaler value.
 *
 * @param val - prescaler value.
*/
template<typename ..._devices>
lmcu_static_inline void set_prescaler(uint16_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::PSC::set(val);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns auto-reload register value
*/
template<typename _device>
lmcu_static_inline uint16_t get_period()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::ARR::get();
}

/**
 * @brief Set auto-reload register value
 *
 * @param val - value
*/
template<typename ..._devices>
lmcu_static_inline void set_period(uint16_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::ARR::set(val);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns repetition counter value
*/
template<typename _device>
lmcu_static_inline uint8_t get_repetition()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::RCR::get();
}

/**
 * @brief Set repetition counter value
 * @param val - value
*/
template<typename ..._devices>
lmcu_static_inline void set_repetition(uint8_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::RCR::set(val);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns dead-time generator duration
*/
template<typename _device>
lmcu_static_inline uint8_t get_deadtime()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::BDTR::get() & inst::BDTR::DTG_MASK;
}

/**
 * @brief Set dead-time generator duration
 * @param val - duration value
*/
template<typename ..._devices>
lmcu_static_inline void set_deadtime(uint8_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer);

    inst::BDTR::clr_b(inst::BDTR::DTG_MASK);
    inst::BDTR::set_b(val);
  };

  (_do(_devices{}), ...);
}

/**
 * @brief Returns DMA destination address
*/
template<typename _device>
lmcu_static_inline uint32_t dma_address()
{
  static_assert(_device::dev_class == dev_class::timer);

  using inst = detail::inst_t<_device::id>;
  return inst::DMAR::base;
}

/**
 * @brief For input channel returns counter value transferred by the last input capture event,
 *        for output channel returns compare register value
*/
template<typename _ch>
lmcu_static_inline uint16_t ch_value()
{
  static_assert(_ch::dev_class == dev_class::timer_in_channel ||
                _ch::dev_class == dev_class::timer_out_channel);

  using inst = detail::inst_t<_ch::id>;

  switch(_ch::channel)
  {
  case timer::channel::_1: return inst::CCR1::get();
  case timer::channel::_2: return inst::CCR2::get();
  case timer::channel::_3: return inst::CCR3::get();
  default:                 return inst::CCR4::get();
  }
}

/**
 * @brief Set output channel compare register value
 * @param val - value
*/
template<typename ..._chs>
lmcu_static_inline void oc_set_pulse(uint16_t val)
{
  auto _do = [&val](auto dev)
  {
    using cfg  = decltype(dev);
    using inst = detail::inst_t<cfg::id>;

    static_assert(cfg::dev_class == dev_class::timer_out_channel);

    switch(cfg::channel)
    {
    case timer::channel::_1: inst::CCR1::set(val); break;
    case timer::channel::_2: inst::CCR2::set(val); break;
    case timer::channel::_3: inst::CCR3::set(val); break;
    case timer::channel::_4: inst::CCR4::set(val); break;
    }
  };

  (_do(_chs{}), ...);
}

} // namespace lmcu::adv_timer

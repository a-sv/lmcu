#pragma once
#include <lmcu/dev/timer>
#include <lmcu/dev/rcc>
#include <lmcu/irq>
#include <lmcu/common>

namespace lmcu::adv_timer {

enum class id { tim1, tim8 };

enum class counter { disable, enable };

enum class update { disable, enable };

enum class update_request_src
{
  // Any of the following events generate an update interrupt or DMA request if enabled.
  // These events can be:
  //   - Counter overflow/underflow
  //   - Setting the UG bit
  //   - Update generation through the slave mode controller
  any,

  // Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
  ovf_udf
};

enum class one_pulse { disable, enable };

enum class direction { up, down };

enum class center_align
{
  // Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
  disable,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is
  // counting down.
  down,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is
  // counting up.
  up,

  // The counter counts up and down alternatively. Output compare interrupt flags of channels
  // configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is
  // counting up or down.
  up_down
};

enum class auto_reload { disable, enable };

enum class dtg_df_div
{
  _1, // tDTS = tCK_INT
  _2, // tDTS = 2 * tCK_INT
  _4  // tDTS = 4*tCK_INT
};

enum class cc_update
{
  disable,
  // COMG bit only
  comg,
  // COMG and TRGI
  comg_trgi
};

enum class dma_trig
{
  // DMA request sent when CCx event occurs.
  cc_evt,
  // DMA requests sent when update event occurs.
  update_evt
};

enum class master_mode
{
  // The UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is
  // generated by the trigger input (slave mode controller configured in reset mode) then the
  // signal on TRGO is delayed compared to the actual reset.
  reset,

  // The Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start
  // several timers at the same time or to control a window in which a slave timer is enable. The
  // Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input
  // when configured in gated mode. When the Counter Enable signal is controlled by the trigger
  // input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit
  // description in TIMx_SMCR register).
  enable,

  // The update event is selected as trigger output (TRGO). For instance a master timer can then be
  // used as a prescaler for a slave timer.
  update,

  // The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was
  // already high), as soon as a capture or a compare match occurred.
  comp_pulse,

  // OC1REF signal is used as trigger output (TRGO).
  comp_1,

  // OC2REF signal is used as trigger output (TRGO).
  comp_2,

  // OC3REF signal is used as trigger output (TRGO).
  comp_3,

  // OC4REF signal is used as trigger output (TRGO).
  comp_4
};

enum class ti1_mux
{
  // The TIMx_CH1 pin is connected to TI1 input
  ch1,

  // The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
  ch1_ch2_ch3
};

enum class slave_mode
{
  // Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal
  // clock.
  disable,

  // Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
  encoder_1,

  // Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
  encoder_2,

  // Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other
  // input.
  encoder_3,

  // Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an
  // update of the registers.
  reset,

  // The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is
  // not reset) as soon as the trigger becomes low. Both start and stop of the counter are
  // controlled.
  gated,

  // The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start
  // of the counter is controlled.
  trigger,

  // External Clock - Rising edges of the selected trigger (TRGI) clock the counter.
  ext_clock
};

enum class slave_trig_sel
{
  itr0, // Internal Trigger 0 (ITR0)
  itr1, // Internal Trigger 1 (ITR1)
  itr2, // Internal Trigger 2 (ITR2)
  itr3, // Internal Trigger 3 (ITR3)
  ti1f_ed, // TI1 Edge Detector (TI1F_ED)
  ti1f_p1, // Filtered Timer Input 1 (TI1FP1)
  ti2f_p2, // Filtered Timer Input 2 (TI2FP2)
  etrf // External Trigger input (ETRF)
};

enum class master_slave_mode { disable, enable };

enum class ext_trig_filter
{
  // Defines the frequency used to sample ETRP signal and the length of the digital filter applied
  // to ETRP. The digital filter is made of an event counter in which N consecutive events are
  // needed to validate a transition on the output.
  disable,
  ckint_n2, // fSAMPLING = fCK_INT,   N=2
  ckint_n4, // fSAMPLING = fCK_INT,   N=4
  ckint_n8, // fSAMPLING = fCK_INT,   N=8
  dts2_n6,  // fSAMPLING = fDTS / 2,  N=6
  dts2_n8,  // fSAMPLING = fDTS / 2,  N=8
  dts4_n6,  // fSAMPLING = fDTS / 4,  N=6
  dts4_n8,  // fSAMPLING = fDTS / 4,  N=8
  dts8_n6,  // fSAMPLING = fDTS / 8,  N=6
  dts8_n8,  // fSAMPLING = fDTS / 8,  N=8
  dts16_n5, // fSAMPLING = fDTS / 16, N=5
  dts16_n6, // fSAMPLING = fDTS / 16, N=6
  dts16_n8, // fSAMPLING = fDTS / 16, N=8
  dts32_n5, // fSAMPLING = fDTS / 32, N=5
  dts32_n6, // fSAMPLING = fDTS / 32, N=6
  dts32_n8  // fSAMPLING = fDTS / 32, N=8
};

enum class ext_trig_div { _1, _2, _4, _8 };

enum class ext_clock { disable, enable };

enum class ext_trig_polarity { low, high };

enum class main_output { disable, enable };

enum class main_auto_output { disable, enable };

enum class break_polarity { low, high };

enum class break_input { disable, enable };

enum class off_state_run { low, high };

enum class off_state_idle { low, high };

enum class lock { off, level_1, level_2, level_3 };

enum class dma_burst_length
{
  _1,
  _2,
  _3,
  _4,
  _5,
  _6,
  _7,
  _8,
  _9,
  _10,
  _11,
  _12,
  _13,
  _14,
  _15,
  _16,
  _17,
  _18
};

enum class dma_base_address
{
  cr1,
  cr2,
  smcr,
  dier,
  sr,
  egr,
  ccmr1,
  ccmr2,
  ccer,
  cnt,
  psc,
  arr,
  rcr,
  ccr1,
  ccr2,
  ccr3,
  ccr4,
  bdtr
};

enum class channel { _1, _2, _3, _4 };

enum class channel_en { disable, enable };

enum class channel_n_en { disable, enable };

enum class channel_polarity { low, high };

enum class channel_n_polarity { low, high };

enum class events : uint32_t
{
  lmcu_flags,

  ui   = device::TIM1::DIER::UIE,   // Update interrupt
  cc1i = device::TIM1::DIER::CC1IE, // Capture/Compare 1 interrupt
  cc2i = device::TIM1::DIER::CC2IE, // Capture/Compare 2 interrupt
  cc3i = device::TIM1::DIER::CC3IE, // Capture/Compare 3 interrupt
  cc4i = device::TIM1::DIER::CC4IE, // Capture/Compare 4 interrupt
  comi = device::TIM1::DIER::COMIE, // COM interrupt
  ti   = device::TIM1::DIER::TIE,   // Trigger interrupt
  bi   = device::TIM1::DIER::BIE,   // Break interrupt
  ud   = device::TIM1::DIER::UDE,   // Update DMA request
  cc1d = device::TIM1::DIER::CC1DE, // Capture/Compare 1 DMA request
  cc2d = device::TIM1::DIER::CC2DE, // Capture/Compare 2 DMA request
  cc3d = device::TIM1::DIER::CC3DE, // Capture/Compare 3 DMA request
  cc4d = device::TIM1::DIER::CC4DE, // Capture/Compare 4 DMA request
  comd = device::TIM1::DIER::COMDE, // COM DMA request
  tde  = device::TIM1::DIER::TDE    // Trigger DMA request
};

enum class out_idle { low, high };

enum class out_n_idle { low, high };

enum class out_fast { disable, enable };

enum class out_preload { disable, enable };

enum class out_mode
{
  frozen,
  active_on_match,
  inactive_on_match,
  toggle,
  force_inactive,
  force_active,
  pwm_1,
  pwm_2
};

enum class out_clear { disable, enable };

struct brk_irq : nvic::irq_config {};

struct up_irq : nvic::irq_config {};

struct trg_com_irq : nvic::irq_config {};

struct cc_irq : nvic::irq_config {};

template<auto ..._args>
struct dev
{
  struct config
  {
    static constexpr auto dev_class = lmcu::dev_class::timer;

    static constexpr auto id = option::get<adv_timer::id, _args...>();

    // Timer counter enable/disable.
    static constexpr auto counter = option::get<adv_timer::counter, _args...>(adv_timer::
                                                                              counter::disable);
    // Enable/disable UEV event generation.
    static constexpr auto update = option::get<adv_timer::update, _args...>(adv_timer::update::
                                                                            enable);
    // Update request source.
    static constexpr auto update_request_src = option::get<adv_timer::update_request_src, _args...>(
                                                 adv_timer::update_request_src::any);
    // One pulse mode.
    static constexpr auto one_pulse = option::get<adv_timer::one_pulse, _args...>(
                                        adv_timer::one_pulse::disable);
    // Count direction.
    static constexpr auto direction = option::get<adv_timer::direction, _args...>(adv_timer::
                                                                                  direction::up);
    //  Center-aligned mode selection.
    static constexpr auto center_align = option::get<adv_timer::center_align, _args...>(
                                           adv_timer::center_align::disable);
    // Center-aligned mode selection.
    static constexpr auto auto_reload = option::get<adv_timer::auto_reload, _args...>(
                                          adv_timer::auto_reload::disable);
    // Dead time generator and digital filter clock division.
    static constexpr auto dtg_df_div = option::get<adv_timer::dtg_df_div, _args...>(
                                         adv_timer::dtg_df_div::_1);
    // Capture/compare control update selection.
    static constexpr auto cc_update = option::get<adv_timer::cc_update, _args...>(
                                        adv_timer::cc_update::disable);
    // Capture/compare DMA selection.
    static constexpr auto dma_trig = option::get<adv_timer::dma_trig, _args...>(
                                       adv_timer::dma_trig::cc_evt);
    // Master mode selection.
    static constexpr auto master_mode = option::get<adv_timer::master_mode, _args...>(
                                          adv_timer::master_mode::reset);
    // TI1 selection.
    static constexpr auto ti1_mux = option::get<adv_timer::ti1_mux, _args...>(
                                      adv_timer::ti1_mux::ch1);
    // Slave mode selection.
    static constexpr auto slave_mode = option::get<adv_timer::slave_mode, _args...>(
                                         adv_timer::slave_mode::disable);
    // Slave trigger selection.
    static constexpr auto slave_trig_sel = option::get<adv_timer::slave_trig_sel, _args...>(
                                             adv_timer::slave_trig_sel::itr0);
    // Master/slave mode.
    static constexpr auto master_slave_mode = option::get<adv_timer::master_slave_mode, _args...>(
                                                adv_timer::master_slave_mode::disable);
    // External trigger filter.
    static constexpr auto ext_trig_filter = option::get<adv_timer::ext_trig_filter, _args...>(
                                              adv_timer::ext_trig_filter::disable);
    // External trigger prescaler.
    static constexpr auto ext_trig_div = option::get<adv_timer::ext_trig_div, _args...>(
                                           adv_timer::ext_trig_div::_1);
    // External clock enable.
    static constexpr auto ext_clock = option::get<adv_timer::ext_clock, _args...>(
                                        adv_timer::ext_clock::disable);
    // External trigger polarity.
    static constexpr auto ext_trig_polarity = option::get<adv_timer::ext_trig_polarity, _args...>(
                                                adv_timer::ext_trig_polarity::high);
    // Enabled events.
    static constexpr auto events = option::get<adv_timer::events, _args...>(adv_timer::events(0));
    // Channels main output control.
    static constexpr auto main_output = option::get<adv_timer::main_output, _args...>(
                                          adv_timer::main_output::disable);
    // Automatic output control (activate main output if break input is not be active).
    static constexpr auto main_auto_output = option::get<adv_timer::main_auto_output, _args...>(
                                               adv_timer::main_auto_output::disable);
    // Break input polarity control.
    static constexpr auto break_polarity = option::get<adv_timer::break_polarity, _args...>(
                                             adv_timer::break_polarity::low);
    // Break input enable control.
    static constexpr auto break_input = option::get<adv_timer::break_input, _args...>(
                                          adv_timer::break_input::disable);
    // Off-state for Run mode.
    static constexpr auto off_state_run = option::get<adv_timer::off_state_run, _args...>(
                                            adv_timer::off_state_run::low);
    // Off-state for Idle mode.
    static constexpr auto off_state_idle = option::get<adv_timer::off_state_idle, _args...>(
                                             adv_timer::off_state_idle::low);
    // Lock config
    static constexpr auto lock = option::get<adv_timer::lock, _args...>(adv_timer::lock::off);
    // DMA burst length
    static constexpr auto dma_burst_length = option::get<adv_timer::dma_burst_length, _args...>(
                                               adv_timer::dma_burst_length::_1);
    // Initial register for DMA burst
    static constexpr auto dma_base_address = option::get<adv_timer::dma_base_address, _args...>(
                                               adv_timer::dma_base_address::cr1);
    // Enable BRK irq
    static constexpr auto brk_irq = option::get<adv_timer::brk_irq, _args...>();
    // Enable UP irq
    static constexpr auto up_irq = option::get<adv_timer::up_irq, _args...>();
    // Enable TRG_COM irq
    static constexpr auto trg_com_irq = option::get<adv_timer::trg_com_irq, _args...>();
    // Enable CC irq
    static constexpr auto cc_irq = option::get<adv_timer::cc_irq, _args...>();

    static_assert(!option::is_null<id>());

    static_assert(option::check<
      std::tuple<
        adv_timer::id,
        adv_timer::counter,
        adv_timer::update,
        adv_timer::update_request_src,
        adv_timer::one_pulse,
        adv_timer::direction,
        adv_timer::center_align,
        adv_timer::auto_reload,
        adv_timer::dtg_df_div,
        adv_timer::cc_update,
        adv_timer::dma_trig,
        adv_timer::master_mode,
        adv_timer::ti1_mux,
        adv_timer::slave_trig_sel,
        adv_timer::master_slave_mode,
        adv_timer::ext_trig_filter,
        adv_timer::ext_trig_div,
        adv_timer::ext_clock,
        adv_timer::ext_trig_polarity,
        adv_timer::events,
        adv_timer::main_output,
        adv_timer::main_auto_output,
        adv_timer::break_polarity,
        adv_timer::break_input,
        adv_timer::off_state_run,
        adv_timer::off_state_idle,
        adv_timer::brk_irq,
        adv_timer::up_irq,
        adv_timer::trg_com_irq,
        adv_timer::cc_irq
      >,
      _args...
    >());
  };

  /**
   * @brief Enable/disable counter
   *
   * @param en - true = enable, false = disable
  */
  lmcu_static_inline void counter_enable(bool en);

  /**
   * @brief Read event flags
  */
  lmcu_static_inline events get_events();

  /**
   * @brief Clear event flags
  */
  lmcu_static_inline void clr_events(events);

  /**
   * @brief Generate events
  */
  lmcu_static_inline void gen_events(events);

  /**
   * @brief Returns the current counter value.
  */
  lmcu_static_inline uint16_t get_counter();

  /**
   * @brief Set counter value.
   *
   * @param val - counter value.
  */
  lmcu_static_inline void set_counter(uint16_t val);

  /**
   * @brief Returns current prescaler value.
  */
  lmcu_static_inline uint16_t get_prescaler();

  /**
   * @brief Set prescaler value.
   *
   * @param val - prescaler value.
  */
  lmcu_static_inline void set_prescaler(uint16_t val);

  /**
   * @brief Returns auto-reload register value
  */
  lmcu_static_inline uint16_t get_period();

  /**
   * @brief Set auto-reload register value
   *
   * @param val - value
  */
  lmcu_static_inline void set_period(uint16_t val);

  /**
   * @brief Returns repetition counter value
  */
  lmcu_static_inline uint8_t get_repetition();

  /**
   * @brief Set repetition counter value
   * @param val - value
  */
  lmcu_static_inline void set_repetition(uint8_t val);

  /**
   * @brief Returns dead-time generator duration
  */
  lmcu_static_inline uint8_t get_deadtime();

  /**
   * @brief Set dead-time generator duration
   * @param val - duration value
  */
  lmcu_static_inline void set_deadtime(uint8_t val);

  /**
   * @brief Returns DMA destination address
  */
  lmcu_static_inline uint32_t dma_address();
};

template<auto ..._args>
struct input
{
  struct config
  {
    static constexpr auto dev_class = lmcu::dev_class::timer_in_channel;

    static constexpr auto id = option::get<adv_timer::id, _args...>();

    // Channel number
    static constexpr auto channel = option::get<adv_timer::channel, _args...>();

    static_assert(option::check<
      std::tuple<
        adv_timer::id,
        adv_timer::channel
      >,
      _args...
    >());
  };
};

template<auto ..._args>
struct output
{
  struct config
  {
    static constexpr auto dev_class = lmcu::dev_class::timer_out_channel;

    static constexpr auto id = option::get<adv_timer::id, _args...>();

    // Channel number
    static constexpr auto channel = option::get<adv_timer::channel, _args...>();
    // Channel output enable
    static constexpr auto channel_en = option::get<adv_timer::channel_en, _args...>(
                                         adv_timer::channel_en::disable);
    // N channel output enable
    static constexpr auto channel_n_en = option::get<adv_timer::channel_n_en, _args...>(
                                           adv_timer::channel_n_en::disable);
    // Output Compare polarity
    static constexpr auto channel_polarity = option::get<adv_timer::channel_polarity, _args...>(
                                               adv_timer::channel_polarity::high);
    // N channel Output Compare polarity
    static constexpr auto channel_n_polarity = option::get<adv_timer::channel_n_polarity, _args...>(
                                                 adv_timer::channel_n_polarity::high);
    // Output idle state
    static constexpr auto out_idle = option::get<adv_timer::out_idle, _args...>(
                                       adv_timer::out_idle::low);
    // Output idle state (on inverted channel)
    static constexpr auto out_n_idle = option::get<adv_timer::out_n_idle, _args...>(
                                         adv_timer::out_n_idle::low);
    // Output Compare fast enable
    static constexpr auto out_fast = option::get<adv_timer::out_fast, _args...>(
                                       adv_timer::out_fast::disable);
    // Output Compare preload enable
    static constexpr auto out_preload = option::get<adv_timer::out_preload, _args...>(
                                          adv_timer::out_preload::disable);
    // Output Compare mode
    static constexpr auto out_mode = option::get<adv_timer::out_mode, _args...>(
                                       adv_timer::out_mode::frozen);
    // Output Compare clear (OCRef cleared as soon as a High level is detected on ETRF input)
    static constexpr auto out_clear = option::get<adv_timer::out_clear, _args...>(
                                        adv_timer::out_clear::disable);

    static_assert(!option::is_null<id>() || !option::is_null<channel>());

    static_assert(option::check<
      std::tuple<
        adv_timer::id,
        adv_timer::channel,
        adv_timer::channel_en,
        adv_timer::channel_n_en,
        adv_timer::channel_polarity,
        adv_timer::out_idle,
        adv_timer::out_n_idle,
        adv_timer::out_fast,
        adv_timer::out_preload,
        adv_timer::out_mode,
        adv_timer::out_clear
      >,
      _args...
    >());
  };

  /**
   * @brief Returns compare register value
  */
  lmcu_static_inline uint16_t get_pulse();

  /**
   * @brief Set compare register value
   * @param val - value
  */
  lmcu_static_inline void set_pulse(uint16_t val);
};

namespace detail {

template<id _id>
struct inst;

template<id _id>
using inst_t = typename inst<_id>::type;

template<>
struct inst<id::tim1> { using type = device::TIM1; };

template<>
struct inst<id::tim8> { using type = device::TIM8; };

template<typename _dev>
void configure_timer()
{
  using cfg  = typename _dev::config;
  using inst = detail::inst_t<cfg::id>;

  // Disable counter
  inst::CR1::clr_b(inst::CR1::CEN);

  {
    auto r = inst::CR1::get();

    if constexpr(cfg::update == update::enable) {
      r &= ~inst::CR1::UDIS;
    }
    else {
      r |= inst::CR1::UDIS;
    }

    if constexpr(cfg::update_request_src == update_request_src::any) {
      r &= ~inst::CR1::URS;
    }
    else {
      r |= inst::CR1::URS;
    }

    if constexpr(cfg::one_pulse == one_pulse::disable) {
      r &= ~inst::CR1::OPM;
    }
    else {
      r |= inst::CR1::OPM;
    }

    if constexpr(cfg::direction == direction::up) {
      r &= ~inst::CR1::DIR;
    }
    else {
      r |= inst::CR1::DIR;
    }

    r &= ~inst::CR1::CMS_MASK;
    switch(cfg::center_align)
    {
    case center_align::down:    r |= inst::CR1::CMS_CENTER_ALIGNED_MODE1; break;
    case center_align::up:      r |= inst::CR1::CMS_CENTER_ALIGNED_MODE2; break;
    case center_align::up_down: r |= inst::CR1::CMS_CENTER_ALIGNED_MODE3; break;
    default: break;
    }

    if constexpr(cfg::auto_reload == auto_reload::disable) {
      r &= ~inst::CR1::ARPE;
    }
    else {
      r |= inst::CR1::ARPE;
    }

    r &= ~inst::CR1::CKD_MASK;
    switch(cfg::dtg_df_div)
    {
    case dtg_df_div::_2: r |= inst::CR1::CKD_2; break;
    case dtg_df_div::_4: r |= inst::CR1::CKD_4; break;
    default: break;
    }

    inst::CR1::set(r);
  }

  {
    auto r = inst::CR2::get();

    if constexpr(cfg::cc_update == cc_update::disable) {
      r &= ~inst::CR2::CCPC;
    }
    else {
      r |= inst::CR2::CCPC;
      if constexpr(cfg::cc_update == cc_update::comg) {
        r &= ~inst::CR2::CCUS;
      }
      else {
        r |= inst::CR2::CCUS;
      }
    }

    if constexpr(cfg::dma_trig == dma_trig::cc_evt) {
      r &= ~inst::CR2::CCDS;
    }
    else {
      r |= inst::CR2::CCDS;
    }

    r &= ~inst::CR2::MMS_MASK;
    switch(cfg::master_mode)
    {
    case master_mode::enable:     r |= inst::CR2::MMS_ENABLE;        break;
    case master_mode::update:     r |= inst::CR2::MMS_UPDATE;        break;
    case master_mode::comp_pulse: r |= inst::CR2::MMS_COMPARE_PULSE; break;
    case master_mode::comp_1:     r |= inst::CR2::MMS_CMP_OC1REF;    break;
    case master_mode::comp_2:     r |= inst::CR2::MMS_CMP_OC2REF;    break;
    case master_mode::comp_3:     r |= inst::CR2::MMS_CMP_OC3REF;    break;
    case master_mode::comp_4:     r |= inst::CR2::MMS_CMP_OC4REF;    break;
    default: break;
    }

    if constexpr(cfg::ti1_mux == ti1_mux::ch1) {
      r &= ~inst::CR2::TI1S;
    }
    else {
      r |= inst::CR2::TI1S;
    }

    inst::CR2::set(r);
  }

  inst::SMCR::set(0);

  if constexpr(cfg::slave_mode != slave_mode::disable) {
    uint32_t r = 0;

    switch(cfg::slave_trig_sel)
    {
    case slave_trig_sel::itr0:    r |= inst::SMCR::TS_ITR0;    break;
    case slave_trig_sel::itr1:    r |= inst::SMCR::TS_ITR1;    break;
    case slave_trig_sel::itr2:    r |= inst::SMCR::TS_ITR2;    break;
    case slave_trig_sel::itr3:    r |= inst::SMCR::TS_ITR3;    break;
    case slave_trig_sel::ti1f_ed: r |= inst::SMCR::TS_TI1F_ED; break;
    case slave_trig_sel::ti1f_p1: r |= inst::SMCR::TS_TI1FP1;  break;
    case slave_trig_sel::ti2f_p2: r |= inst::SMCR::TS_TI2FP2;  break;
    case slave_trig_sel::etrf:    r |= inst::SMCR::TS_ETRF;    break;
    default: break;
    }
    // Apply TS
    inst::SMCR::set(r);

    switch(cfg::slave_mode)
    {
    case slave_mode::encoder_1: r |= inst::SMCR::SMS_ENCODER_MODE_1;        break;
    case slave_mode::encoder_2: r |= inst::SMCR::SMS_ENCODER_MODE_2;        break;
    case slave_mode::encoder_3: r |= inst::SMCR::SMS_ENCODER_MODE_3;        break;
    case slave_mode::reset:     r |= inst::SMCR::SMS_RESET_MODE;            break;
    case slave_mode::gated:     r |= inst::SMCR::SMS_GATED_MODE;            break;
    case slave_mode::trigger:   r |= inst::SMCR::SMS_TRIGGER_MODE;          break;
    case slave_mode::ext_clock: r |= inst::SMCR::SMS_EXTERNAL_CLOCK_MODE_1; break;
    default: break;
    }

    if constexpr(cfg::master_slave_mode == master_slave_mode::enable) { r |= inst::SMCR::MSM; }

    switch(cfg::ext_trig_filter)
    {
    case ext_trig_filter::ckint_n2: r |= inst::SMCR::ETF_CK_INT_N2;    break;
    case ext_trig_filter::ckint_n4: r |= inst::SMCR::ETF_CK_INT_N4;    break;
    case ext_trig_filter::ckint_n8: r |= inst::SMCR::ETF_CK_INT_N8;    break;
    case ext_trig_filter::dts2_n6:  r |= inst::SMCR::ETF_DTS_DIV2_N6;  break;
    case ext_trig_filter::dts2_n8:  r |= inst::SMCR::ETF_DTS_DIV2_N8;  break;
    case ext_trig_filter::dts4_n6:  r |= inst::SMCR::ETF_DTS_DIV4_N6;  break;
    case ext_trig_filter::dts4_n8:  r |= inst::SMCR::ETF_DTS_DIV4_N8;  break;
    case ext_trig_filter::dts8_n6:  r |= inst::SMCR::ETF_DTS_DIV8_N6;  break;
    case ext_trig_filter::dts8_n8:  r |= inst::SMCR::ETF_DTS_DIV8_N8;  break;
    case ext_trig_filter::dts16_n5: r |= inst::SMCR::ETF_DTS_DIV16_N5; break;
    case ext_trig_filter::dts16_n6: r |= inst::SMCR::ETF_DTS_DIV16_N6; break;
    case ext_trig_filter::dts16_n8: r |= inst::SMCR::ETF_DTS_DIV16_N8; break;
    case ext_trig_filter::dts32_n5: r |= inst::SMCR::ETF_DTS_DIV32_N5; break;
    case ext_trig_filter::dts32_n6: r |= inst::SMCR::ETF_DTS_DIV32_N6; break;
    case ext_trig_filter::dts32_n8: r |= inst::SMCR::ETF_DTS_DIV32_N8; break;
    default: break;
    }

    switch(cfg::ext_trig_div)
    {
    case ext_trig_div::_2: r |= inst::SMCR::ETPS_ETRP_DIV2; break;
    case ext_trig_div::_4: r |= inst::SMCR::ETPS_ETRP_DIV4; break;
    case ext_trig_div::_8: r |= inst::SMCR::ETPS_ETRP_DIV8; break;
    default: break;
    }

    if constexpr(cfg::ext_clock == ext_clock::enable) { r |= inst::SMCR::ECE; }

    if constexpr(cfg::ext_trig_polarity == ext_trig_polarity::low) { r |= inst::SMCR::ETP; }

    inst::SMCR::set(r);
  }

  inst::DIER::set(flags::value(cfg::events));

  {
    auto r = inst::BDTR::get();

    if constexpr(cfg::main_output == main_output::enable) {
      r |= inst::BDTR::MOE;
    }
    else {
      r &= ~inst::BDTR::MOE;
    }

    if constexpr(cfg::main_auto_output == main_auto_output::enable) {
      r |= inst::BDTR::AOE;
    }
    else {
      r &= ~inst::BDTR::AOE;
    }

    if constexpr(cfg::break_polarity == break_polarity::high) {
      r |= inst::BDTR::BKP;
    }
    else {
      r &= ~inst::BDTR::BKP;
    }

    if constexpr(cfg::break_input == break_input::enable) {
      r |= inst::BDTR::BKE;
    }
    else {
      r &= ~inst::BDTR::BKE;
    }

    if constexpr(cfg::off_state_run == off_state_run::high) {
      r |= inst::BDTR::OSSR;
    }
    else {
      r &= ~inst::BDTR::OSSR;
    }

    if constexpr(cfg::off_state_idle == off_state_idle::high) {
      r |= inst::BDTR::OSSI;
    }
    else {
      r &= ~inst::BDTR::OSSI;
    }

    r &= ~inst::BDTR::LOCK_MASK;
    switch(cfg::lock)
    {
    case lock::level_1: r |= inst::BDTR::LOCK_LEVEL_1; break;
    case lock::level_2: r |= inst::BDTR::LOCK_LEVEL_2; break;
    case lock::level_3: r |= inst::BDTR::LOCK_LEVEL_3; break;
    default: break;
    }

    inst::BDTR::set(r);
  }

  {
    auto r = inst::DCR::get();

    r &= inst::DCR::DBL_MASK | inst::DCR::DBA_MASK;
    r |= uint32_t(cfg::dma_burst_length) << inst::DCR::DBL_POS;
    r |= uint32_t(cfg::dma_base_address) << inst::DCR::DBA_POS;

    inst::DCR::set(r);
  }

  constexpr auto brk_irqn = (cfg::id == id::tim1)? device::irqn::tim1_brk : device::irqn::tim8_brk;
  if constexpr(!option::is_null<cfg::brk_irq>()) {
    nvic::set_priority<brk_irqn, cfg::brk_irq>();
    nvic::enable_irq<brk_irqn>();
  }
  else {
    nvic::disable_irq<brk_irqn>();
  }

  constexpr auto up_irqn = (cfg::id == id::tim1)? device::irqn::tim1_up : device::irqn::tim8_up;
  if constexpr(!option::is_null<cfg::up_irq>()) {
    nvic::set_priority<up_irqn, cfg::up_irq>();
    nvic::enable_irq<up_irqn>();
  }
  else {
    nvic::disable_irq<up_irqn>();
  }

  constexpr auto trg_com_irqn = (cfg::id == id::tim1)? device::irqn::tim1_trg_com :
                                                       device::irqn::tim8_trg_com;
  if constexpr(!option::is_null<cfg::trg_com_irq>()) {
    nvic::set_priority<trg_com_irqn, cfg::trg_com_irq>();
    nvic::enable_irq<trg_com_irqn>();
  }
  else {
    nvic::disable_irq<trg_com_irqn>();
  }

  constexpr auto cc_irqn = (cfg::id == id::tim1)? device::irqn::tim1_cc : device::irqn::tim8_cc;
  if constexpr(!option::is_null<cfg::cc_irq>()) {
    nvic::set_priority<cc_irqn, cfg::cc_irq>();
    nvic::enable_irq<cc_irqn>();
  }
  else {
    nvic::disable_irq<cc_irqn>();
  }

  if constexpr(cfg::counter == counter::enable) {
    inst::CR1::set_b(inst::CR1::CEN);
  }
}

template<typename _dev>
void configure_input_channel()
{
}

template<typename _dev>
void configure_output_channel()
{
  using cfg  = typename _dev::config;
  using inst = detail::inst_t<cfg::id>;

  constexpr auto ch_n = uint32_t(cfg::channel);

  {
    constexpr uint32_t ois[] = {inst::CR2::OIS1, inst::CR2::OIS2, inst::CR2::OIS3, inst::CR2::OIS4};
    constexpr uint32_t ois_n[] = {inst::CR2::OIS1N, inst::CR2::OIS2N, inst::CR2::OIS3N};

    auto r = inst::CR2::get();

    if constexpr(cfg::out_idle == out_idle::low) {
      r &= ~ois[ch_n];
    }
    else {
      r |= ois[ch_n];
    }

    if constexpr(cfg::channel < channel::_4) {
      if constexpr(cfg::out_n_idle == out_n_idle::low) {
        r &= ~ois_n[ch_n];
      }
      else {
        r |= ois_n[ch_n];
      }
    }

    inst::CR2::set(r);
  }

  {
    constexpr uint32_t ccmr_mask[] = {
      inst::CCMR1::CC1S_MASK | inst::CCMR1::OC1FE_MASK | inst::CCMR1::OC1PE_MASK |
      inst::CCMR1::OC1M_MASK | inst::CCMR1::OC1CE,

      inst::CCMR1::CC2S_MASK | inst::CCMR1::OC2FE_MASK | inst::CCMR1::OC2PE_MASK |
      inst::CCMR1::OC2M_MASK | inst::CCMR1::OC2CE,

      inst::CCMR2::CC3S_MASK | inst::CCMR2::OC3FE_MASK | inst::CCMR2::OC3PE_MASK |
      inst::CCMR2::OC3M_MASK | inst::CCMR2::OC3CE,

      inst::CCMR2::CC4S_MASK | inst::CCMR2::OC4FE_MASK | inst::CCMR2::OC4PE_MASK |
      inst::CCMR2::OC4M_MASK | inst::CCMR2::OC4CE
    };

    uint32_t r;

    if constexpr(ch_n <= 1) {
      r = inst::CCMR1::get();
    }
    else {
      r = inst::CCMR2::get();
    }

    r &= ~ccmr_mask[ch_n];

    constexpr bool _1 = ch_n % 2 == 0;

    if(cfg::out_fast == out_fast::enable) {
      r |= _1? inst::CCMR1::OC1FE : inst::CCMR1::OC2FE;
    }

    if(cfg::out_preload == out_preload::enable) {
      r |= _1? inst::CCMR1::OC1PE : inst::CCMR1::OC2PE;
    }

    switch(cfg::out_mode)
    {
    case out_mode::active_on_match:
      r |= _1? inst::CCMR1::OC1M_ACTIVE : inst::CCMR1::OC2M_ACTIVE;
      break;
    case out_mode::inactive_on_match:
      r |= _1? inst::CCMR1::OC1M_INACTIVE : inst::CCMR1::OC2M_INACTIVE;
      break;
    case out_mode::toggle:
      r |= _1? inst::CCMR1::OC1M_TOGGLE : inst::CCMR1::OC2M_TOGGLE;
      break;
    case out_mode::force_inactive:
      r |= _1? inst::CCMR1::OC1M_FORCE_INACTIVE : inst::CCMR1::OC2M_FORCE_INACTIVE;
      break;
    case out_mode::force_active:
      r |= _1? inst::CCMR1::OC1M_FORCE_ACTIVE : inst::CCMR1::OC2M_FORCE_ACTIVE;
      break;
    case out_mode::pwm_1:
      r |= _1? inst::CCMR1::OC1M_PWM_MODE_1 : inst::CCMR1::OC2M_PWM_MODE_1;
      break;
    case out_mode::pwm_2:
      r |= _1? inst::CCMR1::OC1M_PWM_MODE_2 : inst::CCMR1::OC2M_PWM_MODE_2;
      break;
    default: break;
    }

    if constexpr(cfg::out_clear == out_clear::enable) {
      r |= _1? inst::CCMR1::OC1CE : inst::CCMR1::OC2CE;
    }

    if constexpr(ch_n <= 1) {
      inst::CCMR1::set(r);
    }
    else {
      inst::CCMR2::set(r);
    }
  }

  {
    constexpr uint32_t ccer_mask[] = {
      inst::CCER::CC1E_MASK | inst::CCER::CC1P_MASK | inst::CCER::CC1NE_MASK |
      inst::CCER::CC1NP_MASK,

      inst::CCER::CC2E_MASK | inst::CCER::CC2P_MASK | inst::CCER::CC2NE_MASK |
      inst::CCER::CC2NP_MASK,

      inst::CCER::CC3E_MASK | inst::CCER::CC3P_MASK | inst::CCER::CC3NE_MASK |
      inst::CCER::CC3NP_MASK,

      inst::CCER::CC4E_MASK | inst::CCER::CC4P_MASK
    };

    [[maybe_unused]]
    constexpr uint32_t cce[] = {
      inst::CCER::CC1E, inst::CCER::CC2E, inst::CCER::CC3E, inst::CCER::CC4E
    };

    [[maybe_unused]]
    constexpr uint32_t ccp[] = {
      inst::CCER::CC1P, inst::CCER::CC2P, inst::CCER::CC3P, inst::CCER::CC4P
    };

    [[maybe_unused]]
    constexpr uint32_t ccne[] = { inst::CCER::CC1NE, inst::CCER::CC2NE, inst::CCER::CC3NE };

    [[maybe_unused]]
    constexpr uint32_t ccnp[] = { inst::CCER::CC1NP, inst::CCER::CC2NP, inst::CCER::CC3NP };

    auto r = inst::CCER::get();

    r &= ~ccer_mask[ch_n];

    if constexpr(cfg::channel_en == channel_en::enable) { r |= cce[ch_n]; }
    if constexpr(cfg::channel_polarity == channel_polarity::low) { r |= ccp[ch_n]; }

    if constexpr(ch_n < 4) {
      if constexpr(cfg::channel_n_en == channel_n_en::enable) { r |= ccne[ch_n]; }
      if constexpr(cfg::channel_n_polarity == channel_n_polarity::low) { r |= ccnp[ch_n]; }
    }

    inst::CCER::set(r);
  }
}

} // namespace detail

// ------------------------------------------------------------------------------------------------
// dev class implementation
// ------------------------------------------------------------------------------------------------

template<auto ..._args>
void dev<_args...>::counter_enable(bool en)
{
  using inst = detail::inst_t<config::id>;

  if(en) {
    inst::CR1::set_b(inst::CR1::CEN);
  }
  else {
    inst::CR1::clr_b(inst::CR1::CEN);
  }
}

template<auto ..._args>
events dev<_args...>::get_events()
{
  using inst = detail::inst_t<config::id>;
  return flags::from_value<events>(inst::SR);
}

template<auto ..._args>
void dev<_args...>::clr_events(events evt)
{
  using inst = detail::inst_t<config::id>;
  inst::SR::set((~flags::value(evt)) & 0x1fff);
}

template<auto ..._args>
void dev<_args...>::gen_events(events evt)
{
  using inst = detail::inst_t<config::id>;

  uint32_t r = 0;
  switch(evt)
  {
  case events::ui:   r |= inst::EGR::UG;   break;
  case events::cc1i: r |= inst::EGR::CC1G; break;
  case events::cc2i: r |= inst::EGR::CC2G; break;
  case events::cc3i: r |= inst::EGR::CC3G; break;
  case events::cc4i: r |= inst::EGR::CC4G; break;
  case events::comi: r |= inst::EGR::COMG; break;
  case events::ti:   r |= inst::EGR::TG;   break;
  case events::bi:   r |= inst::EGR::BG;   break;
  default: break;
  }

  inst::EGR::set(r);
}

template<auto ..._args>
uint16_t dev<_args...>::get_counter()
{
  using inst = detail::inst_t<config::id>;
  return inst::CNT::get();
}

template<auto ..._args>
void dev<_args...>::set_counter(uint16_t val)
{
  using inst = detail::inst_t<config::id>;
  inst::CNT::set(val);
}

template<auto ..._args>
uint16_t dev<_args...>::get_prescaler()
{
  using inst = detail::inst_t<config::id>;
  return inst::PSC::get();
}

template<auto ..._args>
void dev<_args...>::set_prescaler(uint16_t val)
{
  using inst = detail::inst_t<config::id>;
  inst::PSC::set(val);
}

template<auto ..._args>
uint16_t dev<_args...>::get_period()
{
  using inst = detail::inst_t<config::id>;
  return inst::ARR::get();
}

template<auto ..._args>
void dev<_args...>::set_period(uint16_t val)
{
  using inst = detail::inst_t<config::id>;
  inst::ARR::set(val);
}

template<auto ..._args>
uint8_t dev<_args...>::get_repetition()
{
  using inst = detail::inst_t<config::id>;
  return inst::RCR::get();
}

template<auto ..._args>
void dev<_args...>::set_repetition(uint8_t val)
{
  using inst = detail::inst_t<config::id>;
  inst::RCR::set(val);
}

template<auto ..._args>
uint8_t dev<_args...>::get_deadtime()
{
  using inst = detail::inst_t<config::id>;
  return inst::BDTR::get() & inst::BDTR::DTG_MASK;
}

template<auto ..._args>
void dev<_args...>::set_deadtime(uint8_t val)
{
  using inst = detail::inst_t<config::id>;
  inst::BDTR::clr_b(inst::BDTR::DTG_MASK);
  inst::BDTR::set_b(val);
}

template<auto ..._args>
uint32_t dev<_args...>::dma_address()
{
  using inst = detail::inst_t<config::id>;
  return inst::DMAR::base;
}

// ------------------------------------------------------------------------------------------------
// output class implementation
// ------------------------------------------------------------------------------------------------

template<auto ..._args>
uint16_t output<_args...>::get_pulse()
{
  using inst = detail::inst_t<config::id>;

  switch(config::channel)
  {
  case channel::_1: return inst::CCR1::get();
  case channel::_2: return inst::CCR2::get();
  case channel::_3: return inst::CCR3::get();
  case channel::_4: return inst::CCR4::get();
  }
}

template<auto ..._args>
void output<_args...>::set_pulse(uint16_t val)
{
  using inst = detail::inst_t<config::id>;

  switch(config::channel)
  {
  case channel::_1: inst::CCR1::set(val); break;
  case channel::_2: inst::CCR2::set(val); break;
  case channel::_3: inst::CCR3::set(val); break;
  case channel::_4: inst::CCR4::set(val); break;
  }
}

// ------------------------------------------------------------------------------------------------

/**
 * @brief Enable clock on timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void on()
{
  using namespace device;

  auto _on = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:  RCC::APB2ENR::set_b(RCC::APB2ENR::TIM1EN);  break;
    case id::tim8:  RCC::APB2ENR::set_b(RCC::APB2ENR::TIM8EN);  break;
    default: break;
    }
  };

  (_on(_ids), ...);
}

/**
 * @brief Disable clock on timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void off()
{
  using namespace device;

  auto _off = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:  RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM1EN);  break;
    case id::tim8:  RCC::APB2ENR::clr_b(RCC::APB2ENR::TIM8EN);  break;
    default: break;
    }
  };

  (_off(_ids), ...);
}

/**
 * @brief Reset timer periph
 *
 * @tparam _ids - timer id list
*/
template<id ..._ids>
lmcu_inline void reset()
{
  using namespace device;

  auto _rst = [](id dev_id)
  {
    switch(dev_id)
    {
    case id::tim1:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM1RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM1RST);
      break;
    case id::tim8:
      RCC::APB2RSTR::set_b(RCC::APB2RSTR::TIM8RST);
      RCC::APB2RSTR::clr_b(RCC::APB2RSTR::TIM8RST);
      break;
    default: break;
    }
  };

  (_rst(_ids), ...);
}

template<typename ..._devices>
void configure()
{
  static auto _cnf = [](auto dev)
  {
    using cfg = typename decltype(dev)::config;

    static_assert(
      cfg::dev_class == dev_class::timer ||
      cfg::dev_class == dev_class::timer_in_channel ||
      cfg::dev_class == dev_class::timer_out_channel
    );

    if constexpr(cfg::dev_class == dev_class::timer) {
      detail::configure_timer<decltype(dev)>();
    }
    else
    if constexpr(cfg::dev_class == dev_class::timer_in_channel) {
      detail::configure_input_channel<decltype(dev)>();
    }
    else
    if constexpr(cfg::dev_class == dev_class::timer_out_channel) {
      detail::configure_output_channel<decltype(dev)>();
    }
  };

  (_cnf(_devices{}), ...);
}

} // namespace lmcu::timer
